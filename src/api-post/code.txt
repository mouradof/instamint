Nom du fichier: ./config.js
Contenu:
import knexfile from "./knexfile.js"
import dotenv from "dotenv"
import { resolve } from "path"

dotenv.config({ path: resolve(".env") })

const config = {
  port: 4002,
  db: knexfile,
  security: {
    password: {
      saltlen: 512,
      keylen: 512,
      iterations: 100000,
      digest: "sha512",
      pepper: process.env.SECURITY__PASSWORD__PEPPER
    }
  },
  cors: {
    allowedOrigins: ["http://localhost:3000"]
  }
}
export default config



Nom du fichier: ./configAWS.cjs
Contenu:
const AWS = require("aws-sdk")
const { config } = require("dotenv")

config()

AWS.config.update({
  accessKeyId: process.env.ACCESS_KEY_ID_S3,
  secretAccessKey: process.env.SECRET_ACCESS_KEY_S3,
  region: "eu-west-3",
  signatureVersion: "v4"
})

const s3 = new AWS.S3()

module.exports = s3



Nom du fichier: ./index.js
Contenu:
import { serve } from "@hono/node-server"
import { Hono } from "hono"
import { cors } from "hono/cors"
import { logger } from "hono/logger"
import knex from "knex"
import BaseModel from "./src/db/models/BaseModel.js"
import config from "./config.js"
import prepareRoutes from "./prepareRoutes.js"
import postRoutes from "./src/routes/posts.js"

const db = knex(config.db)
BaseModel.knex(db)

const app = new Hono()
app.use(logger())

const corsMiddleware = cors({
  origin: config.cors.allowedOrigins,
  allowMethods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
  allowHeaders: ["authorization", "content-type"],
  credentials: true
})

app.use("*", corsMiddleware)

const routesWithCors = [
  "/post/for-you/:id",
  "/post/subscribed/:id",
  "/post/:postId/:userId",
  "/post/liked/:postId/:userId",
  "/post/likes/:postId/:userId",
  "/post/like/:postId/:userId",
  "/post/report/:postId/:userId"
]

routesWithCors.forEach(route => {
  app.use(route, corsMiddleware)
})

prepareRoutes({ app, db })
app.route("/post", postRoutes)

serve({
  fetch: app.fetch,
  port: config.port
})

// eslint-disable-next-line no-console
console.log(`Listening on : ${config.port}`)



Nom du fichier: ./knexfile.js
Contenu:
import { config } from "dotenv"
import { resolve } from "path"

config()

const isMigration = process.env.KNEX_CONTEXT === "migration"

const knexfile = {
  client: "pg",
  connection: {
    host: isMigration ? process.env.DB_HOST_MIGRATIONS : process.env.DB_HOST_API,
    port: process.env.DB_PORT,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_DATABASE
  },
  migrations: {
    directory: resolve("src/db/migrations"),
    stub: resolve("src/db/migration.stub")
  },
  seeds: {
    directory: resolve("src/db/seeds")
  }
}

export default knexfile



Nom du fichier: ./package.json
Contenu:
{
  "name": "api-relation",
  "version": "1.0.0",
  "description": "",
  "type": "module",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node index.js",
    "dev": "nodemon --legacy-watch index.js",
    "migrate": "KNEX_CONTEXT=migration knex migrate:latest",
    "rollback": "KNEX_CONTEXT=migration knex migrate:rollback",
    "seed": "KNEX_CONTEXT=migration knex seed:run"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@faker-js/faker": "^8.4.1",
    "nodemon": "^3.1.0"
  },
  "dependencies": {
    "@heroicons/react": "^1.0.6",
    "@hono/node-server": "^1.10.0",
    "@hono/zod-validator": "^0.2.1",
    "axios": "^1.6.8",
    "dotenv": "^16.4.5",
    "hono": "^4.2.4",
    "knex": "^3.1.0",
    "next": "^14.2.1",
    "nodemon": "^3.1.0",
    "objection": "^3.1.4",
    "pg": "^8.11.5",
    "winston": "^3.13.0",
    "zod": "^3.22.4"
  }
}



Nom du fichier: ./prepareRoutes.js
Contenu:
import prepareRoutesForYou from "./src/routes/posts/ForYouRoute.js"
import prepareRoutesSubscribed from "./src/routes/posts/SubscribedRoute.js"
import prepareRoutesLike from "./src/routes/posts/LikeRoute.js"
import prepareRoutesReport from "./src/routes/posts/ReportRoute.js"
import prepareRoutesDeletePost from "./src/routes/posts/DeletePostRoute.js"

const prepareRoutes = ctx => {
  prepareRoutesForYou(ctx)
  prepareRoutesSubscribed(ctx)
  prepareRoutesLike(ctx)
  prepareRoutesReport(ctx)
  prepareRoutesDeletePost(ctx)
}

export default prepareRoutes



Nom du fichier: ./src/db/hashPassword.js
Contenu:
import { pbkdf2 as pbkdf2Callback, randomBytes } from "crypto"
import { promisify } from "util"
import config from "../../config.js"

const pbkdf2 = promisify(pbkdf2Callback)

const hashPassword = async (password, salt = randomBytes(config.security.password.saltlen).toString("hex")) => [
  (
    await pbkdf2(
      `${password}${config.security.password.pepper}`,
      salt,
      config.security.password.iterations,
      config.security.password.keylen,
      config.security.password.digest
    )
  ).toString("hex"),
  salt
]

export default hashPassword



Nom du fichier: ./src/db/migration.stub
Contenu:
export const up = async (knex) => {}

export const down = async (knex) => {}


Nom du fichier: ./src/db/migrations/20240417053419_initialMigration.js
Contenu:
export const up = async knex => {
  await knex.schema.createTable("posts", table => {
    table.increments("id").primary()
    table.integer("ownerId").unsigned().references("id").inTable("users").onDelete("SET NULL")
    table.datetime("createdAt", { precision: 3 }).defaultTo(knex.fn.now(3))
    table.text("description").notNullable().defaultTo("")
    table.string("imageUrl").notNullable()
  })

  await knex.schema.createTable("likes", table => {
    table.integer("userId").unsigned().references("id").inTable("users").onDelete("CASCADE")
    table.integer("postId").unsigned().references("id").inTable("posts").onDelete("CASCADE")
    table.primary(["userId", "postId"])
  })

  await knex.schema.createTable("follows", table => {
    table.integer("followerId").unsigned().references("id").inTable("users").onDelete("CASCADE")
    table.integer("followedId").unsigned().references("id").inTable("users").onDelete("CASCADE")
    table.primary(["followerId", "followedId"])
  })

  await knex.schema.createTable("reports", table => {
    table.integer("postId").unsigned().references("id").inTable("posts").onDelete("CASCADE")
    table.integer("userId").unsigned().references("id").inTable("users").onDelete("CASCADE")
    table.text("reason").notNullable()
    table.datetime("createdAt", { precision: 3 }).defaultTo(knex.fn.now(3))
    table.primary(["postId", "userId"])
  })

  await knex.schema.createTable("comments", table => {
    table.increments("id").primary()
    table.integer("postId").references("id").inTable("posts").onDelete("CASCADE")
    table.integer("userId").references("id").inTable("users").onDelete("CASCADE")
    table.string("content", 255).notNullable()
    table.timestamp("createdAt").defaultTo(knex.fn.now())
    table.timestamp("updatedAt").defaultTo(knex.fn.now())
  })
}

export const down = async knex => {
  await knex.raw('DROP TABLE IF EXISTS "reports" CASCADE')
  await knex.raw('DROP TABLE IF EXISTS "likes" CASCADE')
  await knex.raw('DROP TABLE IF EXISTS "follows" CASCADE')
  await knex.raw('DROP TABLE IF EXISTS "posts" CASCADE')
  await knex.raw('DROP TABLE IF EXISTS "comments" CASCADE')
}



Nom du fichier: ./src/db/models/BaseModel.js
Contenu:
import { Model } from "objection"

class BaseModel extends Model {}

export default BaseModel



Nom du fichier: ./src/db/models/CommentModel.js
Contenu:
import BaseModel from "./BaseModel.js"

class CommentModel extends BaseModel {
  static get tableName() {
    return "comments"
  }

  static get idColumn() {
    return "id"
  }

  static get jsonSchema() {
    return {
      type: "object",
      required: ["postId", "userId", "content"],
      properties: {
        id: { type: "integer" },
        postId: { type: "integer" },
        userId: { type: "integer" },
        content: { type: "string", minLength: 1, maxLength: 255 },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
}

export default CommentModel



Nom du fichier: ./src/db/models/FollowModel.js
Contenu:
import BaseModel from "./BaseModel.js"
import UserModel from "./UserModel.js"

class FollowModel extends BaseModel {
  static tableName = "follows"

  static get relationMappings() {
    return {
      follower: {
        relation: BaseModel.BelongsToOneRelation,
        modelClass: UserModel,
        join: {
          from: "follows.followerId",
          to: "users.id"
        }
      },
      followed: {
        relation: BaseModel.BelongsToOneRelation,
        modelClass: UserModel,
        join: {
          from: "follows.followedId",
          to: "users.id"
        }
      }
    }
  }
}

export default FollowModel



Nom du fichier: ./src/db/models/LikeModel.js
Contenu:
import BaseModel from "./BaseModel.js"
import UserModel from "./UserModel.js"
import PostModel from "./PostModel.js"

class LikeModel extends BaseModel {
  static tableName = "likes"

  static get idColumn() {
    return ["userId", "postId"]
  }

  static get relationMappings() {
    return {
      user: {
        relation: BaseModel.BelongsToOneRelation,
        modelClass: UserModel,
        join: {
          from: "likes.userId",
          to: "users.id"
        }
      },
      post: {
        relation: BaseModel.BelongsToOneRelation,
        modelClass: PostModel,
        join: {
          from: "likes.postId",
          to: "posts.id"
        }
      }
    }
  }
}

export default LikeModel



Nom du fichier: ./src/db/models/PostModel.js
Contenu:
import BaseModel from "./BaseModel.js"
import UserModel from "./UserModel.js"

class PostModel extends BaseModel {
  static tableName = "posts"

  static get relationMappings() {
    return {
      owner: {
        relation: BaseModel.BelongsToOneRelation,
        modelClass: UserModel,
        join: {
          from: "posts.ownerId",
          to: "users.id"
        }
      }
    }
  }
}

export default PostModel



Nom du fichier: ./src/db/models/ReportModel.js
Contenu:
import BaseModel from "./BaseModel.js"
import UserModel from "./UserModel.js"
import PostModel from "./PostModel.js"

class ReportModel extends BaseModel {
  static tableName = "reports"

  static get idColumn() {
    return ["postId", "userId"]
  }

  static get relationMappings() {
    return {
      user: {
        relation: BaseModel.BelongsToOneRelation,
        modelClass: UserModel,
        join: {
          from: "reports.userId",
          to: "users.id"
        }
      },
      post: {
        relation: BaseModel.BelongsToOneRelation,
        modelClass: PostModel,
        join: {
          from: "reports.postId",
          to: "posts.id"
        }
      }
    }
  }
}

export default ReportModel



Nom du fichier: ./src/db/models/UserModel.js
Contenu:
import BaseModel from "./BaseModel.js"
import PostModel from "./PostModel.js"

class UserModel extends BaseModel {
  static tableName = "users"

  static get relationMappings() {
    return {
      postsOwned: {
        relation: BaseModel.HasManyRelation,
        modelClass: PostModel,
        join: {
          from: "users.id",
          to: "posts.ownerId"
        }
      }
    }
  }
}

export default UserModel



Nom du fichier: ./src/db/seeds/00_initial.js
Contenu:
export const seed = async knex => {
  await knex.raw("TRUNCATE TABLE posts RESTART IDENTITY CASCADE")
  await knex.raw("TRUNCATE TABLE users RESTART IDENTITY CASCADE")
}



Nom du fichier: ./src/db/seeds/01_initialUsers.js
Contenu:
import { faker } from "@faker-js/faker"
import hashPassword from "../hashPassword.js"

export const seed = async knex => {
  const users = []
  for (let i = 1; i <= 20; i += 1) {
    const [passwordHash, passwordSalt] = await hashPassword("Password123?")
    const username = faker.internet.userName()
    const email = faker.internet.email()
    const bio = faker.lorem.text()
    const profileImage = faker.image.avatarLegacy()
    users.push({
      username,
      email,
      passwordHash,
      passwordSalt,
      bio,
      profileImage
    })
  }
  await knex("users").insert(users)
}



Nom du fichier: ./src/db/seeds/02_initialPosts.js
Contenu:
import { faker } from "@faker-js/faker"
import UserModel from "../models/UserModel.js"

export const seed = async knex => {
  UserModel.knex(knex)
  const users = await UserModel.query().select("id")
  const postData = []

  for (let i = 1; i <= 30; i += 1) {
    const ownerId = faker.number.int({ min: 1, max: users.length })
    postData.push({
      ownerId,
      createdAt: faker.date.recent(),
      description: faker.lorem.lines(2),
      imageUrl: faker.image.imageUrl()
    })
  }
  await knex("posts").insert(postData)
}



Nom du fichier: ./src/db/seeds/03_initialFollows.js
Contenu:
import { faker } from "@faker-js/faker"
import UserModel from "../models/UserModel.js"

export const seed = async knex => {
  UserModel.knex(knex)
  const users = await UserModel.query().select("id")
  const followData = []

  users.forEach(user => {
    let followedIds = new Set()

    while (followedIds.size < 5) {
      let followedId = faker.number.int({ min: 1, max: users.length })

      if (followedId !== user.id && !followedIds.has(followedId)) {
        followedIds.add(followedId)
        followData.push({
          followerId: user.id,
          followedId: followedId
        })
      }
    }
  })
  await knex("follows").insert(followData)
}



Nom du fichier: ./src/db/seeds/04_initialLikes.js
Contenu:
import { faker } from "@faker-js/faker"
import UserModel from "../models/UserModel.js"
import PostModel from "../models/PostModel.js"

export const seed = async knex => {
  UserModel.knex(knex)
  PostModel.knex(knex)

  const users = await UserModel.query().select("id")
  const posts = await PostModel.query().select("id")
  const likeData = []

  for (const post of posts) {
    const numLikes = faker.number.int({ min: 1, max: 20 })
    const shuffledUsers = faker.helpers.shuffle(users.map(user => user.id))

    for (let i = 0; i < numLikes; i++) {
      likeData.push({
        userId: shuffledUsers[i],
        postId: post.id
      })
    }
  }

  await knex("likes").insert(likeData)
}



Nom du fichier: ./src/db/seeds/05_initialReports.js
Contenu:
import { faker } from "@faker-js/faker"
import UserModel from "../models/UserModel.js"
import PostModel from "../models/PostModel.js"

export const seed = async knex => {
  UserModel.knex(knex)
  PostModel.knex(knex)

  const users = await UserModel.query().select("id")
  const posts = await PostModel.query().select("id")
  const reportData = []

  for (const post of posts) {
    const numReports = faker.number.int({ min: 1, max: users.length })
    const shuffledUsers = faker.helpers.shuffle(users.map(user => user.id))

    for (let i = 0; i < numReports; i++) {
      reportData.push({
        userId: shuffledUsers[i],
        postId: post.id,
        reason: faker.lorem.sentence(),
        createdAt: faker.date.recent()
      })
    }
  }

  await knex("reports").insert(reportData)
}



Nom du fichier: ./src/errors.js
Contenu:
const HTTP_STATUS_CODES = {
  UNAUTHORIZED: 401,
  BAD_REQUEST: 400,
  NOT_FOUND: 404,
  INTERNAL_SERVER_ERROR: 500,
  OK: 200
}

const HTTP_ERRORS = {
  MISSING_AUTH_HEADER: "Missing authorization header",
  INVALID_PAGE_NUMBER: "Invalid page number",
  NO_FOLLOWED_USERS: "No followed users",
  NO_FOLLOWED_IDS: "No followed ids",
  NO_FOLLOWED_POSTS: "No followed posts",
  FETCH_POSTS_FAILED: "Failed to fetch posts",
  ALREADY_LIKED: "You have already liked this post",
  NOT_LIKED: "You have not liked this post",
  LIKE_STATUS_ERROR: "Error checking like status for post",
  RETRIEVE_LIKE_COUNT_ERROR: "Error retrieving like count for post",
  LIKE_ADDED: "Like added to post",
  LIKE_REMOVED: "Like removed from post",
  NOT_AUTHORIZED_OR_NOT_FOUND: "Not authorized to delete this post or post not found",
  POST_DELETED: "Post successfully deleted",
  DELETE_POST_FAILED: "Failed to delete post"
}

export { HTTP_STATUS_CODES, HTTP_ERRORS }



Nom du fichier: ./src/routes/posts/DeletePostRoute.js
Contenu:
import { Hono } from "hono"
import { z } from "zod"
import { idValidator } from "../validators.js"
import { zValidator } from "@hono/zod-validator"
import PostModel from "../../db/models/PostModel.js"
import { HTTP_STATUS_CODES, HTTP_ERRORS } from "../../errors.js"

const prepareRoutesDeletePost = ({ app }) => {
  const DeletePostData = new Hono()

  const postDeleteSchema = z.object({
    postId: idValidator,
    userId: idValidator
  })

  DeletePostData.delete("/post/:postId/:userId", zValidator("param", postDeleteSchema), async c => {
    const postId = c.req.valid("param").postId
    const userId = c.req.valid("param").userId

    try {
      const post = await PostModel.query().where({ id: postId, ownerId: userId }).first()

      if (!post) {
        return c.json(
          {
            success: false,
            message: HTTP_ERRORS.NOT_AUTHORIZED_OR_NOT_FOUND
          },
          HTTP_STATUS_CODES.NOT_FOUND
        )
      }

      await PostModel.query().where({ id: postId, ownerId: userId }).delete()

      return c.json(
        {
          success: true,
          message: HTTP_ERRORS.POST_DELETED
        },
        HTTP_STATUS_CODES.OK
      )
    } catch (error) {
      return c.json(
        {
          success: false,
          message: `${HTTP_ERRORS.DELETE_POST_FAILED}: ${error.message}`
        },
        HTTP_STATUS_CODES.INTERNAL_SERVER_ERROR
      )
    }
  })

  app.route("/", DeletePostData)
}

export default prepareRoutesDeletePost



Nom du fichier: ./src/routes/posts/ForYouRoute.js
Contenu:
import { Hono } from "hono"
import { z } from "zod"
import { idValidator, stringValidator } from "../validators.js"
import { zValidator } from "@hono/zod-validator"
import FollowModel from "../../db/models/FollowModel.js"
import PostModel from "../../db/models/PostModel.js"
import { HTTP_STATUS_CODES, HTTP_ERRORS } from "../../errors.js"

const prepareRoutesForYou = ({ app }) => {
  const forYouData = new Hono()

  const idForYouSchema = z.object({
    id: idValidator
  })
  const pageForYouSchema = z.object({
    page: stringValidator
  })

  forYouData.get(
    "/post/for-you/:id",
    zValidator("param", idForYouSchema),
    zValidator("query", pageForYouSchema),
    async c => {
      try {
        const userId = c.req.valid("param").id
        const page = parseInt(c.req.valid("query").page, 10) || 0

        if (page < 0) {
          return c.json(
            {
              success: false,
              message: HTTP_ERRORS.INVALID_PAGE_NUMBER
            },
            HTTP_STATUS_CODES.BAD_REQUEST
          )
        }

        const directFollows = await FollowModel.query().where("followerId", userId)
        const followedIds = directFollows.map(user => user.followedId)
        const indirectFollows = await FollowModel.query().whereIn("followerId", followedIds)
        const allFollowedIds = [...followedIds, ...indirectFollows.map(user => user.followedId)]

        const allPosts = await PostModel.query()
          .whereIn("ownerId", allFollowedIds)
          .join("users", "posts.ownerId", "=", "users.id")
          .select("posts.*", "users.username", "users.profileImage")
          .limit(10 * (page + 1))

        const formattedPosts = allPosts.map(post => ({
          postId: post.id,
          ownerId: post.ownerId,
          profileImage: post.profileImage,
          createdAt: post.createdAt,
          description: post.description,
          imageUrl: post.imageUrl,
          username: post.username,
          userId: post.userId
        }))

        return c.json(
          {
            success: true,
            result: formattedPosts,
            hasMore: allPosts.length > 10 * (page + 1)
          },
          HTTP_STATUS_CODES.OK
        )
      } catch (error) {
        return c.json(
          {
            success: false,
            message: `${HTTP_ERRORS.FETCH_POSTS_FAILED}: ${error.message}`
          },
          HTTP_STATUS_CODES.INTERNAL_SERVER_ERROR
        )
      }
    }
  )

  app.route("/", forYouData)
}

export default prepareRoutesForYou



Nom du fichier: ./src/routes/posts/LikeRoute.js
Contenu:
import { Hono } from "hono"
import { z } from "zod"
import { zValidator } from "@hono/zod-validator"
import { idValidator } from "../validators.js"
import { HTTP_STATUS_CODES, HTTP_ERRORS } from "../../errors.js"
import LikeModel from "../../db/models/LikeModel.js"

const prepareRoutesLike = ({ app }) => {
  const likeData = new Hono()

  const likeSchema = z.object({
    postId: idValidator,
    userId: idValidator.optional()
  })

  likeData.get("/post/liked/:postId/:userId", zValidator("param", likeSchema), async c => {
    const postId = c.req.valid("param").postId
    const userId = c.req.valid("param").userId

    try {
      const existingLike = await LikeModel.query().where({ postId, userId }).first()

      return c.json({ success: true, isLiked: Boolean(existingLike) }, HTTP_STATUS_CODES.OK)
    } catch (error) {
      return c.json(
        {
          success: false,
          message: `${HTTP_ERRORS.LIKE_STATUS_ERROR} ${postId}: ${error.message}`
        },
        HTTP_STATUS_CODES.INTERNAL_SERVER_ERROR
      )
    }
  })

  likeData.get("/post/likes/:postId/:userId", zValidator("param", likeSchema), async c => {
    const postId = c.req.valid("param").postId

    try {
      const likeCount = await LikeModel.query().where({ postId }).count("* as likeCount")

      return c.json(
        {
          success: true,
          postId,
          likeCount: likeCount[0].likeCount
        },
        HTTP_STATUS_CODES.OK
      )
    } catch (error) {
      return c.json(
        {
          success: false,
          message: `${HTTP_ERRORS.RETRIEVE_LIKE_COUNT_ERROR} ${postId}: ${error.message}`
        },
        HTTP_STATUS_CODES.INTERNAL_SERVER_ERROR
      )
    }
  })

  likeData.post("/post/like/:postId/:userId", zValidator("param", likeSchema), async c => {
    const postId = c.req.valid("param").postId
    const userId = c.req.valid("param").userId

    try {
      const existingLike = await LikeModel.query().where({ postId, userId }).first()

      if (existingLike) {
        return c.json(
          {
            success: false,
            message: HTTP_ERRORS.ALREADY_LIKED
          },
          HTTP_STATUS_CODES.NOT_FOUND
        )
      }

      await LikeModel.query().insert({ postId, userId })

      return c.json(
        {
          success: true,
          message: HTTP_ERRORS.LIKE_ADDED
        },
        HTTP_STATUS_CODES.OK
      )
    } catch (error) {
      return c.json(
        {
          success: false,
          message: `${HTTP_ERRORS.LIKE_STATUS_ERROR} ${postId}: ${error.message}`
        },
        HTTP_STATUS_CODES.INTERNAL_SERVER_ERROR
      )
    }
  })

  likeData.delete("/post/like/:postId/:userId", zValidator("param", likeSchema), async c => {
    const postId = c.req.valid("param").postId
    const userId = c.req.valid("param").userId

    try {
      const existingLike = await LikeModel.query().where({ postId, userId }).first()

      if (!existingLike) {
        return c.json(
          {
            success: false,
            message: HTTP_ERRORS.NOT_LIKED
          },
          HTTP_STATUS_CODES.NOT_FOUND
        )
      }

      await LikeModel.query().where({ postId, userId }).delete()

      return c.json(
        {
          success: true,
          message: HTTP_ERRORS.LIKE_REMOVED
        },
        HTTP_STATUS_CODES.OK
      )
    } catch (error) {
      return c.json(
        {
          success: false,
          message: `${HTTP_ERRORS.LIKE_STATUS_ERROR} ${postId}: ${error.message}`
        },
        HTTP_STATUS_CODES.INTERNAL_SERVER_ERROR
      )
    }
  })

  app.route("/", likeData)
}

export default prepareRoutesLike



Nom du fichier: ./src/routes/posts/ReportRoute.js
Contenu:
import { Hono } from "hono"
import { z } from "zod"
import { idValidator, stringValidator } from "../validators.js"
import { zValidator } from "@hono/zod-validator"
import { HTTP_STATUS_CODES } from "../../errors.js"
import ReportModel from "../../db/models/ReportModel.js"

const prepareRoutesReport = ({ app }) => {
  const reportData = new Hono()

  const reportSchema = z.object({
    postId: idValidator,
    userId: idValidator,
    reason: stringValidator.optional()
  })

  reportData.post(
    "/post/report/:postId/:userId",
    zValidator("param", reportSchema.pick({ postId: true, userId: true })),
    zValidator("json", reportSchema.pick({ reason: true })),
    async c => {
      const postId = c.req.valid("param").postId
      const userId = c.req.valid("param").userId
      const reason = c.req.valid("json").reason

      try {
        const existingReport = await ReportModel.query().where({ postId, userId }).first()

        if (existingReport) {
          await ReportModel.query().where({ postId, userId }).update({ reason })
        } else {
          await ReportModel.query().insert({ postId, userId, reason })
        }

        return c.json(
          {
            success: true,
            message: "Report submitted successfully"
          },
          HTTP_STATUS_CODES.OK
        )
      } catch (error) {
        return c.json(
          {
            success: false,
            message: `Failed to submit report: ${error.message}`
          },
          HTTP_STATUS_CODES.INTERNAL_SERVER_ERROR
        )
      }
    }
  )

  app.route("/", reportData)
}

export default prepareRoutesReport



Nom du fichier: ./src/routes/posts/SubscribedRoute.js
Contenu:
import { Hono } from "hono"
import { z } from "zod"
import { idValidator, stringValidator } from "../validators.js"
import { zValidator } from "@hono/zod-validator"
import FollowModel from "../../db/models/FollowModel.js"
import PostModel from "../../db/models/PostModel.js"
import { HTTP_STATUS_CODES, HTTP_ERRORS } from "../../errors.js"

const prepareRoutesSubscribed = ({ app }) => {
  const subscribedData = new Hono()

  const idSubscribedSchema = z.object({
    id: idValidator
  })
  const pageSubscribedSchema = z.object({
    page: stringValidator
  })

  subscribedData.get(
    "/post/subscribed/:id",
    zValidator("param", idSubscribedSchema),
    zValidator("query", pageSubscribedSchema),
    async c => {
      try {
        const userId = c.req.valid("param").id
        const page = parseInt(c.req.valid("query").page, 10) || 0

        if (page < 0) {
          return c.json(
            {
              success: false,
              message: HTTP_ERRORS.INVALID_PAGE_NUMBER
            },
            HTTP_STATUS_CODES.BAD_REQUEST
          )
        }

        const followedUsers = await FollowModel.query().where("followerId", userId)

        if (followedUsers.length === 0) {
          return c.json(
            {
              success: false,
              message: HTTP_ERRORS.NO_FOLLOWED_USERS
            },
            HTTP_STATUS_CODES.NOT_FOUND
          )
        }

        const followedIds = followedUsers.map(user => user.followedId)

        if (followedIds.length === 0) {
          return c.json(
            {
              success: false,
              message: HTTP_ERRORS.NO_FOLLOWED_IDS
            },
            HTTP_STATUS_CODES.NOT_FOUND
          )
        }

        const followedPosts = await PostModel.query()
          .whereIn("ownerId", followedIds)
          .join("users", "posts.ownerId", "=", "users.id")
          .select(
            "posts.id as postId",
            "posts.createdAt",
            "posts.description",
            "posts.imageUrl",
            "posts.ownerId",
            "users.username",
            "users.profileImage"
          )
          .orderBy("posts.createdAt", "desc")

        if (followedPosts.length === 0) {
          return c.json(
            {
              success: false,
              message: HTTP_ERRORS.NO_FOLLOWED_POSTS
            },
            HTTP_STATUS_CODES.NOT_FOUND
          )
        }

        return c.json(
          {
            success: true,
            result: followedPosts,
            hasMore: followedPosts.length > 10
          },
          HTTP_STATUS_CODES.OK
        )
      } catch (error) {
        return c.json(
          {
            success: false,
            message: `${HTTP_ERRORS.FETCH_POSTS_FAILED}: ${error.message}`
          },
          HTTP_STATUS_CODES.INTERNAL_SERVER_ERROR
        )
      }
    }
  )

  app.route("/", subscribedData)
}

export default prepareRoutesSubscribed



Nom du fichier: ./src/routes/posts.js
Contenu:
import { Hono } from "hono"
import PostModel from "../db/models/PostModel.js"
import CommentModel from "../db/models/CommentModel.js"
import BaseModel from "../db/models/BaseModel.js"
import knex from "knex"
import config from "../../config.js"

const db = knex(config.db)
BaseModel.knex(db) // Lier l'instance de Knex ici également

const postRoutes = new Hono()

postRoutes.options("/user/:id", c => {
  c.header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
  c.header("Access-Control-Allow-Headers", "authorization, content-type")

  return c
})

postRoutes.get("/user/:id", async c => {
  const id = parseInt(c.req.param("id"), 10)

  if (!id) {
    return c.json({ error: "User ID is required" }, 400)
  }

  try {
    const posts = await PostModel.query().where({ ownerId: id })

    return c.json(posts)
  } catch (error) {
    return c.json({ error: "Failed to fetch user posts" }, 500)
  }
})

postRoutes.get("/:postId/comments", async c => {
  const postId = parseInt(c.req.param("postId"), 10)

  if (!postId) {
    return c.json({ error: "Post ID is required" }, 400)
  }

  try {
    const comments = await CommentModel.query().where({ postId })

    return c.json(comments)
  } catch (error) {
    return c.json({ error: "Failed to fetch comments" }, 500)
  }
})

postRoutes.post("/:postId/comments", async c => {
  const postId = parseInt(c.req.param("postId"), 10)
  const { userId, content } = await c.req.json()

  if (!postId || !userId || !content) {
    return c.json({ error: "Post ID, User ID, and content are required" }, 400)
  }

  try {
    const newComment = await CommentModel.query().insert({
      postId,
      userId,
      content
    })

    return c.json(newComment)
  } catch (error) {
    return c.json({ error: "Failed to add comment", details: error.message }, 500)
  }
})

export default postRoutes



Nom du fichier: ./src/routes/validators.js
Contenu:
import { z } from "zod"

// generic
export const stringValidator = z.string()
export const idValidator = z.string()
export const integerValidator = z.number().int()
export const numberValidator = z.number()
export const booleanValidator = z.boolean()



