Nom du fichier: ./api-relation/config.js
Contenu:
import knexfile from "./knexfile.js"
import dotenv from "dotenv"
import { resolve } from "path"

dotenv.config({ path: resolve(".env") })

const config = {
  port: 4002,
  db: knexfile,
  security: {
    password: {
      saltlen: 512,
      keylen: 512,
      iterations: 100000,
      digest: "sha512",
      pepper: process.env.SECURITY__PASSWORD__PEPPER
    }
  }
}
export default config



Nom du fichier: ./api-relation/configAWS.cjs
Contenu:
const AWS = require("aws-sdk")
const { config } = require("dotenv")

config()

AWS.config.update({
  accessKeyId: process.env.ACCESS_KEY_ID_S3,
  secretAccessKey: process.env.SECRET_ACCESS_KEY_S3,
  region: "eu-west-3",
  signatureVersion: "v4"
})

const s3 = new AWS.S3()

module.exports = s3



Nom du fichier: ./api-relation/index.js
Contenu:
import { serve } from "@hono/node-server"
import { Hono } from "hono"
import { cors } from "hono/cors"
import { logger } from "hono/logger"
import knex from "knex"
import BaseModel from "./src/db/models/BaseModel.js"
import config from "./config.js"
import prepareRoutes from "./prepareRoutes.js"

const db = knex(config.db)
BaseModel.knex(db)

const app = new Hono()
app.use(logger())
app.use(
  cors({
    origin: "*",
    allowMethods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allowedHeaders: ["Authorization", "Content-Type"],
    credentials: true
  })
)

prepareRoutes({ app, db })

serve({
  fetch: app.fetch,
  port: config.port
})

// eslint-disable-next-line no-console
console.log(`Listening on : ${config.port}`)



Nom du fichier: ./api-relation/knexfile.js
Contenu:
import { config } from "dotenv"
import { resolve } from "path"

config()

const isMigration = process.env.KNEX_CONTEXT === "migration"

const knexfile = {
  client: "pg",
  connection: {
    host: isMigration ? process.env.DB_HOST_MIGRATIONS : process.env.DB_HOST_API,
    port: process.env.DB_PORT,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_DATABASE
  },
  migrations: {
    directory: resolve("src/db/migrations"),
    stub: resolve("src/db/migration.stub")
  },
  seeds: {
    directory: resolve("src/db/seeds")
  }
}

export default knexfile



Nom du fichier: ./api-relation/prepareRoutes.js
Contenu:
import prepareRoutesTeabags from "./src/routes/prepareRoutesTeabags.js"
import prepareRoutesCreateTeabag from "./src/routes/prepareRoutesCreateTeabag.js"

const prepareRoutes = ctx => {
  prepareRoutesTeabags(ctx)
  prepareRoutesCreateTeabag(ctx)
}

export default prepareRoutes



Nom du fichier: ./api-relation/src/routes/prepareRoutesCreateTeabag.js
Contenu:
import { Hono } from "hono"
import pkg from "../../configAWS.cjs"
import UserModel from "../db/models/UserModel.js"
import TeabagModel from "../db/models/TeabagModel.js"
import GroupMemberModel from "../db/models/GroupMemberModel.js"
import { v4 as uuidv4 } from "uuid"
import { z } from "zod"
import { zValidator } from "@hono/zod-validator"
import { booleanValidator, numberValidator, stringValidator } from "../validators.js"

const generateUniqueFileName = originalFileName => {
  const uniqueId = uuidv4()
  const fileExtension = originalFileName.split(".").pop()

  return `${uniqueId}.${fileExtension}`
}

const prepareRoutesCreateTeabag = ({ app }) => {
  const createTeabag = new Hono()

  const teabagSchema = z.object({
    name: stringValidator,
    description: stringValidator.optional(),
    isPrivate: booleanValidator.optional(),
    userEmails: z.array(stringValidator).optional(),
    image: z
      .object({
        name: stringValidator,
        lastModified: numberValidator,
        size: numberValidator,
        type: stringValidator
      })
      .optional()
  })

  createTeabag.post("teabags/:userId/createTeabag", zValidator("form", teabagSchema), async c => {
    try {
      const userId = c.req.param("userId")
      const userExists = await UserModel.query().findById(userId)

      if (!userExists) {
        c.status(404)

        return c.json({
          success: false,
          message: "User not found"
        })
      }

      const body = await c.req.parseBody({ all: true })
      const { image, name, description, isPrivate, invitedEmailsUsers } = body

      const invitedEmails = JSON.parse(invitedEmailsUsers)
      let uniqueImagename = null

      if (image) {
        uniqueImagename = generateUniqueFileName(image.name)

        const fileBuffer = await image.arrayBuffer()
        const buffer = Buffer.from(fileBuffer)
        const params = {
          Bucket: process.env.BUCKET_NAME_S3,
          Key: uniqueImagename,
          Body: buffer,
          ContentType: "image/png"
        }

        await pkg.upload(params).promise()
      }

      const newTeabag = await TeabagModel.query().insert({
        ownerId: userId,
        name,
        description: description || null,
        private: isPrivate || false,
        image: uniqueImagename
      })

      let groupMembers = [
        {
          userId,
          teabagId: newTeabag.id
        }
      ]

      if (invitedEmails && invitedEmails.length > 0) {
        const users = await UserModel.query().whereIn("email", invitedEmails)
        const additionalGroupMembers = users.map(user => ({
          userId: user.id,
          teabagId: newTeabag.id
        }))
        groupMembers = groupMembers.concat(additionalGroupMembers)
      }

      await GroupMemberModel.query().insert(groupMembers)

      const userCount = await GroupMemberModel.query()
        .where("teabagId", newTeabag.id)
        .count("userId as userCount")
        .first()
      const numberOfUsers = userCount ? userCount.count : 1

      c.status(200)

      return c.json({
        result: newTeabag,
        numberOfUsers,
        success: true,
        message: "Teabag created successfully"
      })
    } catch (error) {
      c.status(500)

      return c.json({
        result: error,
        success: false,
        message: `INTERNAL SERVER ERROR: ${error}`
      })
    }
  })

  app.route("/", createTeabag)
}

export default prepareRoutesCreateTeabag



Nom du fichier: ./api-relation/src/routes/prepareRoutesTeabags.js
Contenu:
import { Hono } from "hono"
import GroupMemberModel from "../db/models/GroupMemberModel.js"
import { zValidator } from "@hono/zod-validator"
import { z } from "zod"
import { idValidator } from "../validators.js"
import TeabagModel from "../db/models/TeabagModel.js"
import pkg from "../../configAWS.cjs"

const prepareRoutesTeabags = ({ app }) => {
  const teabagsData = new Hono()

  const teabagSchema = z.object({
    userId: idValidator
  })
  // Assuming that i'm doing this request with a flat data. I'm waiting for tokken
  teabagsData.get("/teabags/:userId", zValidator("param", teabagSchema), async c => {
    try {
      const userId = c.req.valid("param").userId
      const groupMemberships = await GroupMemberModel.query().where("userId", userId)

      if (!groupMemberships) {
        c.status(404)

        return c.json({
          success: false,
          message: "User has no group"
        })
      }

      const teabagIds = groupMemberships.map(group => group.teabagId)

      if (!teabagIds) {
        c.status(404)

        return c.json({
          success: false,
          message: "404 Not found"
        })
      }

      const teabagsData = await TeabagModel.query().findByIds(teabagIds)

      if (!teabagsData) {
        c.status(404)

        return c.json({
          success: false,
          message: "404 Not found"
        })
      }

      for (const teabag of teabagsData) {
        const userCount = await GroupMemberModel.query()
          .where("teabagId", teabag.id)
          .count("userId as userCount")
          .first()
        teabag.userCount = userCount.userCount || 0

        if (
          teabag.image &&
          !teabag.image.startsWith(
            "https://cloudflare-ipfs.com/ipfs/Qmd3W5DuhgHirLHGVixi6V76LhCkZUz6pnFt5AJBiyvHye/avatar"
          )
        ) {
          teabag.imageBucket = pkg.getSignedUrl("getObject", {
            Bucket: process.env.BUCKET_NAME_S3,
            Key: teabag.image
          })
        } else {
          teabag.imageBucket = teabag.image
        }
      }

      c.status(200)

      return c.json({
        result: teabagsData,
        success: true,
        message: "Data fetched"
      })
    } catch (error) {
      c.status(500)

      return c.json({
        result: error,
        success: false,
        message: `INTERNAL SERVER ERROR: ${error}`
      })
    }
  })

  app.route("/", teabagsData)
}

export default prepareRoutesTeabags



Nom du fichier: ./api-relation/src/validators.js
Contenu:
import { z } from "zod"

// generic
export const stringValidator = z.string()
export const idValidator = z.string()
export const integerValidator = z.number().int()
export const numberValidator = z.number()
export const booleanValidator = z.boolean()



Nom du fichier: ./api-user/config.js
Contenu:
import knexfile from "./knexfile.js"
import dotenv from "dotenv"
import { resolve } from "path"

dotenv.config({ path: resolve(".env") })

const config = {
  port: 4002,
  db: knexfile,
  security: {
    password: {
      saltlen: 512,
      keylen: 512,
      iterations: 100000,
      digest: "sha512",
      pepper: process.env.SECURITY__PASSWORD__PEPPER
    }
  }
}
export default config



Nom du fichier: ./api-user/configAWS.cjs
Contenu:
const AWS = require("aws-sdk")
const { config } = require("dotenv")

config()

AWS.config.update({
  accessKeyId: process.env.ACCESS_KEY_ID_S3,
  secretAccessKey: process.env.SECRET_ACCESS_KEY_S3,
  region: "eu-west-3",
  signatureVersion: "v4"
})

const s3 = new AWS.S3()

module.exports = s3



Nom du fichier: ./api-user/index.js
Contenu:
import { serve } from "@hono/node-server"
import { Hono } from "hono"
import { cors } from "hono/cors"
import { logger } from "hono/logger"
import knex from "knex"
import { authMiddleware } from "./src/middleware/auth.js"
import BaseModel from "./src/db/models/BaseModel.js"
import config from "./config.js"
import userRoutes from "./src/routes/user-routes.js"
import prepareRouteRegister from "./src/routes/register-route.js"
import prepareRouteLogin from "./src/routes/login-route.js"
import prepareRouteVerify from "./src/routes/verify-route.js"
import adminRoute from "./src/routes/admin/admin-route.js"
import superAdminRoute from "./src/routes/superadmin/superadmin-route.js"
import dotenv from "dotenv"

dotenv.config()

const db = knex(config.db)
BaseModel.knex(db)

const app = new Hono()

app.use(logger())
app.use(
  cors({
    origin: "*",
    allowMethods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allowHeaders: ["*"],
    credentials: true
  })
)

app.route("/api/user", userRoutes)
app.use("/api/protected", authMiddleware)
app.route("/admin", adminRoute)
app.route("/superadmin", superAdminRoute)

prepareRouteRegister({ app, db })
prepareRouteLogin({ app, db })
prepareRouteVerify({ app, db })

serve({
  fetch: app.fetch,
  port: config.port
})

// eslint-disable-next-line no-console
console.log(`Server listening on port ${config.port}`)



Nom du fichier: ./api-user/knexfile.js
Contenu:
import { config } from "dotenv"
import { resolve } from "path"

config()

const isMigration = process.env.KNEX_CONTEXT === "migration"

const knexfile = {
  client: "pg",
  connection: {
    host: isMigration ? process.env.DB_HOST_MIGRATIONS : process.env.DB_HOST_API,
    port: process.env.DB_PORT,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_DATABASE
  },
  migrations: {
    directory: resolve("src/db/migrations"),
    stub: resolve("src/db/migration.stub")
  },
  seeds: {
    directory: resolve("src/db/seeds")
  }
}

export default knexfile



Nom du fichier: ./api-user/prepareRoutes.js
Contenu:
import prepareRoutesUsers from "./src/routes/auth-routes.js"
import prepareRouteLogin from "./src/routes/login-route.js"
import prepareRouteRegister from "./src/routes/register-routes.js"
import prepareRouteVerify from "./src/routes/verify-routes.js"

const prepareRoutes = ctx => {
  prepareRouteLogin(ctx)
  prepareRouteRegister(ctx)
  prepareRouteVerify(ctx)
  prepareRoutesUsers(ctx)
}

export default prepareRoutes



Nom du fichier: ./api-user/src/middleware/auth.js
Contenu:
import jwt from "jsonwebtoken"

async function authMiddleware(ctx, next) {
  const authHeader = ctx.req.headers.get("authorization")

  if (!authHeader) {
    ctx.status = 401

    return ctx.json({ message: "Authorization header is missing" })
  }

  const token = authHeader.split(" ")[1]

  if (!token) {
    ctx.status = 401

    return ctx.json({ message: "Auth token is not supplied" })
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET)
    ctx.req.userData = decoded
    await next()
  } catch (error) {
    ctx.status = 401

    return ctx.json({
      message: "Auth failed",
      error: error.message
    })
  }
}

export { authMiddleware }



Nom du fichier: ./api-user/src/routes/admin/admin-route.js
Contenu:
import { Hono } from "hono"
import UserModel from "../../db/models/UserModel.js"

const adminRoute = new Hono()

adminRoute.post("/ban/:id", async c => {
  const { id } = c.req.param()
  const { duration } = await c.req.json()

  let bannedUntil
  const now = new Date()

  switch (duration) {
    case "10m":
      bannedUntil = new Date(now.getTime() + 10 * 60 * 1000) // 10 minutes

      break

    case "12h":
      bannedUntil = new Date(now.getTime() + 12 * 60 * 60 * 1000) // 12 hours

      break

    case "24h":
      bannedUntil = new Date(now.getTime() + 24 * 60 * 60 * 1000) // 24 hours

      break

    case "1w":
      bannedUntil = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000) // 1 week

      break

    case "1m":
      bannedUntil = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000) // 1 month

      break

    case "forever":
      bannedUntil = null // Permanent ban

      break

    default:
      return c.json({ message: "Invalid ban duration" }, 400)
  }

  await UserModel.query().patchAndFetchById(id, {
    isBanned: true,
    bannedUntil: bannedUntil ? bannedUntil.toISOString() : null
  })

  return c.json({ message: "User banned successfully" })
})

adminRoute.post("/unban/:id", async c => {
  const { id } = c.req.param()

  await UserModel.query().patchAndFetchById(id, {
    isBanned: false,
    bannedUntil: null
  })

  return c.json({ message: "User unbanned successfully" })
})

adminRoute.get("/banned", async c => {
  const bannedUsers = await UserModel.query().where("isBanned", true)

  return c.json(bannedUsers)
})

export default adminRoute



Nom du fichier: ./api-user/src/routes/login-route.js
Contenu:
import { Hono } from "hono"
import bcrypt from "bcrypt"
import { sign } from "hono/jwt"
import UserModel from "../db/models/UserModel.js"

const prepareRouteLogin = ({ app }) => {
  const auth = new Hono()

  auth.post("/login", async c => {
    const body = await c.req.json()
    const { email, password } = body

    try {
      const user = await UserModel.query().where({ email }).first()

      if (!user) {
        return c.json({ message: "Email or password is incorrect" }, 401)
      }

      // Met à jour le statut de bannissement si nécessaire
      await UserModel.updateBanStatus(user.id)

      // Rafraîchit les informations utilisateur après la mise à jour du statut de bannissement
      const updatedUser = await UserModel.query().findById(user.id)

      if (updatedUser.isBanned) {
        return c.json({ message: "Account is banned" }, 403)
      }

      const match = await bcrypt.compare(password, updatedUser.passwordHash)

      if (!match) {
        return c.json({ message: "Email or password is incorrect" }, 401)
      }

      const now = new Date().toISOString()

      const lastLoginDate = new Date(updatedUser.lastLoginDate)
      const diffDays = Math.ceil((new Date(now) - lastLoginDate) / (1000 * 60 * 60 * 24))

      if (diffDays > 15) {
        await UserModel.query().deleteById(updatedUser.id)

        return c.json({ message: "Account has been deleted due to inactivity" }, 401)
      }

      try {
        await UserModel.query().patchAndFetchById(updatedUser.id, { lastLoginDate: now })
      } catch (error) {
        return c.json({ message: "Failed to update last login date", error: error.message }, 500)
      }

      if (!updatedUser.emailVerified) {
        return c.json({ message: "Please verify your email address first" }, 401)
      }

      const payload = {
        id: updatedUser.id,
        username: updatedUser.username,
        email: updatedUser.email,
        role: updatedUser.role,
        exp: Math.floor(Date.now() / 1000) + 60 * 5
      }

      const token = await sign(payload, process.env.JWT_SECRET)

      let redirectUrl = "/profile"

      if (updatedUser.role === "role_admin") {
        redirectUrl = "/admin"
      } else if (updatedUser.role === "role_superadmin") {
        redirectUrl = "/superadmin"
      }

      return c.json(
        {
          message: "Auth successful",
          token,
          user: {
            id: updatedUser.id,
            username: updatedUser.username,
            email: updatedUser.email,
            profileImage: updatedUser.profileImage,
            coverImage: updatedUser.coverImage,
            bio: updatedUser.bio,
            followers: updatedUser.followers,
            following: updatedUser.following,
            role: updatedUser.role
          },
          redirectUrl
        },
        200
      )
    } catch (error) {
      return c.json({ message: "Authentication service unavailable", error: error.message }, 500)
    }
  })

  app.route("/auth", auth)
}

export default prepareRouteLogin



Nom du fichier: ./api-user/src/routes/register-route.js
Contenu:
import { Hono } from "hono"
import bcrypt from "bcrypt"
import UserModel from "../db/models/UserModel.js"
import sendVerificationEmail from "../helpers/emailHelper.js"

const prepareRouteRegister = ({ app }) => {
  const auth = new Hono()

  auth.post("/register", async c => {
    const body = await c.req.json()
    const { username, email, password } = body

    try {
      const existingUser = await UserModel.query().where({ email }).first()

      if (existingUser) {
        return c.json({ message: "Email already in use" }, 409)
      }

      const salt = await bcrypt.genSalt(10)
      const hashedPassword = await bcrypt.hash(password, salt)

      const newUser = await UserModel.query().insert({
        username,
        email,
        passwordHash: hashedPassword,
        passwordSalt: salt,
        verifyToken: UserModel.generateVerifyToken(),
        emailVerified: false,
        isBanned: false,
        bannedUntil: null
      })

      await sendVerificationEmail(newUser.email, newUser.verifyToken)

      return c.json(
        {
          message: "User registered. Please check your email to verify your account."
        },
        201
      )
    } catch (error) {
      return c.json({ message: "Error registering user", error: error.message }, 500)
    }
  })

  app.route("/auth", auth)
}

export default prepareRouteRegister



Nom du fichier: ./api-user/src/routes/superadmin/superadmin-route.js
Contenu:
import { Hono } from "hono"
import UserModel from "../../db/models/UserModel.js"

const superAdminRoute = new Hono()

superAdminRoute.get("/", async ctx => {
  const users = await UserModel.query()

  return ctx.json(users)
})

superAdminRoute.put("/:id/role", async ctx => {
  const { id } = ctx.req.param()
  const { role } = await ctx.req.json()

  const updatedUser = await UserModel.query().patchAndFetchById(id, { role })

  if (!updatedUser) {
    return ctx.json({ error: "User not found or role update failed" }, 404)
  }

  return ctx.json(updatedUser)
})

export default superAdminRoute



Nom du fichier: ./api-user/src/routes/user-routes.js
Contenu:
import { Hono } from "hono"
import UserModel from "../db/models/UserModel.js"
import bcrypt from "bcrypt"

const userRoutes = new Hono()

userRoutes.get("/:id", async c => {
  const id = c.req.param("id")

  try {
    const user = await UserModel.query().findById(id)

    if (!user) {
      return c.json({ message: "User not found" }, 404)
    }

    return c.json(user, 200)
  } catch (error) {
    return c.json({ message: "Error fetching user", error: error.message }, 500)
  }
})

userRoutes.get("/search/:name", async c => {
  const name = c.req.param("name").toLowerCase()

  try {
    const users = await UserModel.query().whereRaw("LOWER(username) LIKE ?", [`${name}%`])

    if (users.length === 0) {
      return c.json({ message: "No users found" }, 404)
    }

    return c.json(users, 200)
  } catch (error) {
    return c.json({ message: "Error fetching users", error: error.message }, 500)
  }
})

userRoutes.put("/:id/change-password", async c => {
  const id = c.req.param("id")
  const { oldPassword, newPassword } = await c.req.json()

  try {
    const user = await UserModel.query().findById(id)

    if (!user) {
      return c.json({ message: "User not found" }, 404)
    }

    const validPassword = await bcrypt.compare(oldPassword, user.passwordHash)

    if (!validPassword) {
      return c.json({ message: "Old password is incorrect" }, 403)
    }

    const salt = await bcrypt.genSalt(10)
    const hashedPassword = await bcrypt.hash(newPassword, salt)
    await UserModel.query().patchAndFetchById(id, { passwordHash: hashedPassword })

    return c.json({ message: "Password updated successfully. Please log in again.", logout: true }, 200)
  } catch (error) {
    return c.json({ message: "Error updating password", error: error.message }, 500)
  }
})

userRoutes.put("/:id/update", async c => {
  const id = c.req.param("id")
  const body = await c.req.json()

  if (!body.username || !body.bio) {
    return c.json({ message: "Username and bio fields are required and cannot be empty" }, 400)
  }

  const existingUser = await UserModel.query().where("username", body.username).andWhere("id", "!=", id).first()

  if (existingUser) {
    return c.json({ message: "Username already exists" }, 409)
  }

  const updatedUser = await UserModel.query().patchAndFetchById(id, {
    username: body.username,
    bio: body.bio,
    profileImage: body.profileImage,
    coverImage: body.coverImage
  })

  if (!updatedUser) {
    return c.json({ message: "User not found" }, 404)
  }

  return c.json(updatedUser, 200)
})

userRoutes.delete("/:id", async c => {
  const id = c.req.param("id")
  const { password } = await c.req.json()

  try {
    const user = await UserModel.query().findById(id)

    if (!user) {
      return c.json({ message: "User not found" }, 404)
    }

    const validPassword = await bcrypt.compare(password, user.passwordHash)

    if (!validPassword) {
      return c.json({ message: "Password is incorrect" }, 403)
    }

    await UserModel.query().deleteById(id)

    return c.json({ message: "User deleted successfully" }, 200)
  } catch (error) {
    return c.json({ message: "Error deleting user", error: error.message }, 500)
  }
})

export default userRoutes



Nom du fichier: ./api-user/src/routes/verify-route.js
Contenu:
import { Hono } from "hono"
import UserModel from "../db/models/UserModel.js"

const prepareRouteVerify = ({ app }) => {
  const auth = new Hono()

  auth.get("/verify", async c => {
    const { token } = c.req.query()

    try {
      const user = await UserModel.query().where({ verifyToken: token }).first()

      if (!user) {
        return c.json({ message: "Invalid token" }, 400)
      }

      await UserModel.query()

        .findById(user.id)
        .patch({ emailVerified: true, verifyToken: null })

      return c.redirect("http://localhost:3000/login?verified=true")
    } catch (error) {
      return c.json({ message: "Error verifying email", error: error.message }, 500)
    }
  })

  app.route("/auth", auth)
}

export default prepareRouteVerify



Nom du fichier: ./api-user/src/routes/wallet-route.js
Contenu:
import { Hono } from "hono"
import bcrypt from "bcrypt"
import { sign } from "hono/jwt"
import UserModel from "../db/models/UserModel.js"

const prepareRouteWallet = ({ app }) => {
  const auth = new Hono()

  auth.post("/checkWallet", async c => {
    const body = await c.req.json()
    const { walletAddress } = body

    try {
      const user = await UserModel.query().where({ walletAddress }).first()

      if (user) {
        const payload = {
          id: user.id,
          username: user.username,
          walletAddress: user.walletAddress,
          exp: Math.floor(Date.now() / 1000) + 60 * 5
        }

        const token = await sign(payload, process.env.JWT_SECRET)

        return c.json(
          {
            exists: true,
            token,
            user: {
              id: user.id,
              username: user.username,
              email: user.email,
              walletAddress: user.walletAddress,
              profileImage: user.profileImage,
              coverImage: user.coverImage,
              bio: user.bio,
              followers: user.followers,
              following: user.following
            }
          },
          200
        )
      } else {
        return c.json({ exists: false })
      }
    } catch (error) {
      return c.json({ message: "Error checking wallet", error: error.message }, 500)
    }
  })

  auth.post("/registerWallet", async c => {
    const body = await c.req.json()
    const { username, email, password, walletAddress } = body

    try {
      const existingUser = await UserModel.query().where({ walletAddress }).first()

      if (existingUser) {
        return c.json({ message: "Wallet address already in use" }, 409)
      }

      let passwordHash = null
      let salt = null

      if (password) {
        salt = await bcrypt.genSalt(10)
        passwordHash = await bcrypt.hash(password, salt)
      }

      const newUser = await UserModel.query().insert({
        username,
        email,
        passwordHash,
        passwordSalt: salt,
        walletAddress,
        emailVerified: true // Assuming no email verification needed for wallet login
      })

      const payload = {
        id: newUser.id,
        username: newUser.username,
        walletAddress: newUser.walletAddress,
        exp: Math.floor(Date.now() / 1000) + 60 * 5
      }

      const token = await sign(payload, process.env.JWT_SECRET)

      return c.json(
        {
          message: "User registered successfully",
          token,
          user: {
            id: newUser.id,
            username: newUser.username,
            email: newUser.email,
            walletAddress: newUser.walletAddress,
            profileImage: newUser.profileImage,
            coverImage: newUser.coverImage,
            bio: newUser.bio,
            followers: newUser.followers,
            following: newUser.following
          }
        },
        201
      )
    } catch (error) {
      return c.json({ message: "Error registering user", error: error.message }, 500)
    }
  })

  app.route("/auth", auth)
}

export default prepareRouteWallet



Nom du fichier: ./app/api/config.mjs
Contenu:
const config = {
  apiUser: {
    baseURL: "http://localhost:4000",
    timeout: 5000,
    retryAttempts: 3,
    defaultHeaders: {
      "Content-Type": "application/json"
    }
  },
  apiRelation: {
    baseURL: "http://localhost:4001",
    timeout: 5000,
    retryAttempts: 3,
    defaultHeaders: {
      "Content-Type": "multipart/form-data"
    }
  },
  apiPost: {
    baseURL: "http://localhost:4002",
    timeout: 5000,
    retryAttempts: 3,
    defaultHeaders: {
      "Content-Type": "application/json"
    }
  },
  apiNotification: {
    baseURL: "http://localhost:4003",
    timeout: 5000,
    retryAttempts: 3,
    defaultHeaders: {
      "Content-Type": "application/json"
    }
  },
  apiNFT: {
    baseURL: "http://localhost:4004",
    timeout: 5000,
    retryAttempts: 3,
    defaultHeaders: {
      "Content-Type": "application/json"
    }
  }
}

export default config



Nom du fichier: ./app/api/configAWS.cjs
Contenu:
const AWS = require("aws-sdk")
const { config } = require("dotenv")

config()

AWS.config.update({
  accessKeyId: process.env.ACCESS_KEY_ID_S3,
  secretAccessKey: process.env.SECRET_ACCESS_KEY_S3,
  region: "eu-west-3",
  signatureVersion: "v4"
})

const s3 = new AWS.S3()

module.exports = s3



Nom du fichier: ./app/api/createAPIClient.mjs
Contenu:
import config from "./config.mjs"
import axios from "axios"

const createAPIClient = ({ jwt, apiKey }) => {
  const apiConfig = config[apiKey]

  const client = axios.create({
    baseURL: apiConfig.baseURL,
    timeout: apiConfig.timeout,
    headers: {
      ...(jwt ? { Authorization: `Bearer ${jwt}` } : {}),
      ...apiConfig.defaultHeaders
    }
  })

  return client
}

export default createAPIClient



Nom du fichier: ./app/api/routes.mjs
Contenu:
const createRouteWithQueryParams = (route, query) => {
  if (!query) {
    return route
  }

  const qs = new URLSearchParams(query).toString()

  return `${route}?${qs}`
}

const routes = {
  home: () => "/",
  login: () => "/login",
  register: () => "/register",
  profile: userId => `/profile/${userId}`,
  apiRelation: {
    teabags: {
      userTeabags: idUser => createRouteWithQueryParams(`/teabags/${idUser}`),
      userCreateTeabag: idUser => createRouteWithQueryParams(`teabags/${idUser}/createTeabag`)
    }
  },
  apiUser: {
    profile: userId => `/api/user/${userId}`,
    updateProfile: userId => `/api/user/${userId}/update`,
    search: search => createRouteWithQueryParams(`/api/user/search/${search}`)
  },
  apiPost: {
    post: {
      forYou: (idUser, page) => createRouteWithQueryParams(`/post/for-you/${idUser}?page=${page}`),
      subscribed: (idUser, page) => createRouteWithQueryParams(`/post/subscribed/${idUser}?page=${page}`),
      deletePost: (postId, idUser) => createRouteWithQueryParams(`/post/${postId}/${idUser}`)
    },
    like: {
      likes: (postId, idUser) => createRouteWithQueryParams(`/post/likes/${postId}/${idUser}`),
      like: (postId, idUser) => createRouteWithQueryParams(`/post/like/${postId}/${idUser}`),
      liked: (postId, idUser) => createRouteWithQueryParams(`/post/liked/${postId}/${idUser}`)
    },
    report: {
      report: (postId, idUser) => createRouteWithQueryParams(`/post/report/${postId}/${idUser}`)
    }
  }
}

export default routes



Nom du fichier: ./app/components/Navigation.jsx
Contenu:
import Link from "next/link"

const Navigation = () => {
  return (
    <nav>
      {/* Insère ici d'autres liens si nécessaire */}
      <Link href="/profile">Profile</Link>&nbsp;&nbsp;&nbsp;&nbsp;
      <Link href="/logout">Logout</Link>&nbsp;&nbsp;&nbsp;&nbsp;
      <Link href="/login">Login</Link>&nbsp;&nbsp;&nbsp;&nbsp;
      <Link href="/register">Register</Link>&nbsp;&nbsp;&nbsp;&nbsp;
      <Link href="/home">home</Link>&nbsp;&nbsp;&nbsp;&nbsp;
    </nav>
  )
}

export default Navigation



Nom du fichier: ./app/components/business/DeleteModalPost.jsx
Contenu:
import React, { useState } from "react"
import Modal from "../common/Modal.jsx"
import Toast from "../common/Toast.jsx"
import useAppContext from "@/app/hooks/useContext.jsx"
import { useRouter } from "next/router"
import { CheckIcon } from "@heroicons/react/24/outline"

const DeleteModalPost = ({ isOpen, onClose, postId }) => {
  const {
    state: { session },
    action: { deletePost }
  } = useAppContext()

  const [error, setError] = useState(null)
  const [isDeleted, setIsDeleted] = useState(false)
  const [toast, setToast] = useState({ message: "", isSuccess: false })

  const router = useRouter()

  const showToast = (message, isSuccess) => {
    setToast({ message, isSuccess })
  }

  const handleDelete = async () => {
    try {
      await deletePost({ userId: session.id, postId })
      setIsDeleted(true)
      showToast("Post deleted successfully! Please wait a few moments...", true)
      setTimeout(() => {
        router.reload()
      }, 2000)
    } catch (err) {
      const errorMessage = err.message || "An error occurred while deleting the post."
      setError(errorMessage)
      showToast(errorMessage, false)
    }
  }

  return (
    <Modal isOpen={isOpen} onClose={onClose} title="Are you sure you want to delete this post ?">
      {toast.message && <Toast message={toast.message} isSuccess={toast.isSuccess} />}
      {!isDeleted ? (
        <div className="text-center">
          <button onClick={handleDelete} className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-700">
            Delete
          </button>
          <button onClick={onClose} className="px-4 py-2 ml-4 bg-gray-500 text-white rounded hover:bg-gray-700">
            Cancel
          </button>
          {error && <div className="text-red-500 mt-2">{error}</div>}
        </div>
      ) : (
        <div className="text-center p-4 text-green-500">
          <CheckIcon className="h-10 w-10 text-green-500 mx-auto" />
          Thank you for helping us improve Instamint for the benefit of all.
        </div>
      )}
    </Modal>
  )
}

export default DeleteModalPost



Nom du fichier: ./app/components/business/FeedPost.jsx
Contenu:
import React, { useState, useEffect } from "react"
import Post from "./Post.jsx"
import Toast from "../common/Toast.jsx"
import InfiniteScroll from "react-infinite-scroll-component"
import useAppContext from "@/app/hooks/useContext.jsx"

const Feed = ({ type }) => {
  const {
    state: { session },
    action: { getForyouPost, getSubscribedPost }
  } = useAppContext()

  const [posts, setPosts] = useState([])
  const [hasMore, setHasMore] = useState(true)
  const [page, setPage] = useState(0)
  const [error, setError] = useState(null)

  useEffect(() => {
    const fetchPosts = async () => {
      try {
        if (type === "forYou") {
          const [apiError, apiData] = await getForyouPost({ userId: session.id, page })

          if (apiError) {
            setError(apiError)

            return
          }

          const sortedPosts = apiData.result.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))

          if (page === 0) {
            setPosts(sortedPosts)
          } else {
            setPosts(prevPosts => [...prevPosts, ...sortedPosts])
          }

          setHasMore(apiData.hasMore)
        } else if (type === "subscribed") {
          const [apiError, apiData] = await getSubscribedPost({ userId: session.id, page })

          if (apiError) {
            setError(apiError)

            return
          }

          const sortedPosts = apiData.result.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))

          if (page === 0) {
            setPosts(sortedPosts)
          } else {
            setPosts(prevPosts => [...prevPosts, ...sortedPosts])
          }

          setHasMore(apiData.hasMore)
        }
      } catch (err) {
        setError("Failed to fetch posts")
      }
    }

    fetchPosts()
  }, [type, page, getForyouPost, session.id, getSubscribedPost])

  useEffect(() => {
    setPage(0)
    setPosts([])
  }, [type])

  const fetchMorePosts = () => {
    setPage(prevPage => prevPage + 1)
  }

  return (
    <div className="min-h-screen bg-white" style={{ marginTop: "100px" }}>
      {error && <Toast message={error} isSuccess={false} />}
      <InfiniteScroll dataLength={posts.length} next={fetchMorePosts} hasMore={hasMore}>
        {posts.map(post => {
          return (
            <Post
              key={post.postId}
              username={post.username}
              createdAt={post.createdAt}
              description={post.description}
              imageUrl={post.imageUrl}
              profileImage={post.profileImage}
              postId={post.postId}
              userId={post.userId}
              ownerId={post.ownerId}
            />
          )
        })}
      </InfiniteScroll>
      {posts.length === 0 && !error && <div className="text-center p-4">No posts to display.</div>}
    </div>
  )
}

export default Feed



Nom du fichier: ./app/components/business/OptionsPopupPost.jsx
Contenu:
import React, { useEffect, useRef } from "react"
import { FlagIcon, TrashIcon } from "@heroicons/react/24/outline"

const PostOptionsPopup = ({ onReportClick, onDeleteClick, isAuthor }) => {
  const ref = useRef()

  useEffect(() => {
    const handleClickOutside = event => {
      if (ref.current && !ref.current.contains(event.target)) {
        onReportClick(false)
      }
    }

    document.addEventListener("mousedown", handleClickOutside)

    return () => {
      document.removeEventListener("mousedown", handleClickOutside)
    }
  }, [onReportClick])

  return (
    <div ref={ref} className="absolute right-0 mt-2 w-48 bg-white rounded-md shadow-lg py-1 z-10">
      <button
        onClick={() => onReportClick(true)}
        className="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
      >
        <FlagIcon className="h-5 w-5 inline-block align-middle text-gray-700" />
        <span className="align-middle"> Report </span>
      </button>
      {isAuthor && (
        <button
          onClick={onDeleteClick}
          className="block w-full text-left px-4 py-2 text-sm text-red-500 hover:bg-red-100"
        >
          <TrashIcon className="h-5 w-5 inline-block align-middle text-red-500" />
          <span className="align-middle"> Delete </span>
        </button>
      )}
    </div>
  )
}

export default PostOptionsPopup



Nom du fichier: ./app/components/business/Post.jsx
Contenu:
import React, { useState } from "react"
import { ChatBubbleOvalLeftIcon, EllipsisHorizontalIcon } from "@heroicons/react/24/outline"
import usePostInteractions from "../../hooks/usePostInteractions.jsx"
import { formatDistanceToNow } from "date-fns"
import Toast from "../common/Toast.jsx"
import PostOptionsPopup from "../business/OptionsPopupPost.jsx"
import ReportModal from "./ReportModalPost.jsx"
import DeleteModalPost from "./DeleteModalPost.jsx"
import useAppContext from "@/app/hooks/useContext.jsx"

const Post = ({ postId, profileImage, username, ownerId, createdAt, description, imageUrl }) => {
  const [showOptions, setShowOptions] = useState(false)
  const [showReportModal, setShowReportModal] = useState(false)
  const [showDeleteModal, setShowDeleteModal] = useState(false)
  const { isLiked, likeCount, toggleLike, error } = usePostInteractions(postId)

  const {
    state: { session }
    // This is not dead code, we only comment it out to avoid making too many requests to the bucket because we are limited to 20,000 requests in the free version
    //action: { getImagesBucket }
  } = useAppContext()

  const handleReportClick = shouldShow => {
    setShowReportModal(shouldShow)
    setShowOptions(false)
  }

  const handleDeleteClick = () => {
    setShowDeleteModal(true)
    setShowOptions(false)
  }

  const isAuthor = session.id === ownerId

  const formattedTime = formatDistanceToNow(new Date(createdAt), {
    addSuffix: true
  })

  const mintIcon = "/images/mint.png"
  const mintIconSolid = "/images/mintSolid.png"
  // const mintIcon = {getImagesBucket("mint.png")}
  // const mintIconSolid = getImagesBucket("mintSolid.png")}

  return (
    <div className="border-b border-gray-200 px-4 py-4 bg-white">
      <div className="flex space-x-3">
        <div className="min-w-0 flex-shrink-0">
          <img src={profileImage} alt="Profile image" width={40} height={40} className="rounded-full" />
        </div>
        <div className="flex-1">
          <div className="flex justify-between items-center">
            <div className="flex items-center">
              <h4 className="font-bold text-black text-sm">{username}</h4>
              <span className="text-gray-500 text-xs ml-2">{formattedTime}</span>
            </div>
            <EllipsisHorizontalIcon className="h-5 w-5 text-gray-500" onClick={() => setShowOptions(!showOptions)} />
            {showOptions && (
              <PostOptionsPopup
                onReportClick={handleReportClick}
                onDeleteClick={handleDeleteClick}
                isAuthor={isAuthor}
              />
            )}
          </div>
          <ReportModal isOpen={showReportModal} onClose={() => setShowReportModal(false)} postId={postId} />
          <DeleteModalPost isOpen={showDeleteModal} onClose={() => setShowDeleteModal(false)} postId={postId} />
          {description && <p className="text-sm text-gray-800">{description}</p>}
          {imageUrl && (
            <div className="relative w-full mt-2">
              <img src={imageUrl} alt="Post image" width={399} height={399} className="rounded-lg" />
            </div>
          )}
          <div className="flex justify-between items-center mt-2">
            <div className="flex space-x-4">
              <button onClick={toggleLike} className="flex items-center space-x-1 text-gray-500">
                <img
                  src={isLiked ? mintIconSolid : mintIcon}
                  alt="mint Icon"
                  className="h-4 w-4"
                  width={40}
                  height={40}
                />
                <span className={`ml-1 ${isLiked ? "text-green-500" : "text-gray-500"}`}>{likeCount}</span>
              </button>
              <button className="flex items-center space-x-1 text-gray-500">
                <ChatBubbleOvalLeftIcon className="h-5 w-5" />
              </button>
            </div>
          </div>
        </div>
      </div>
      {error && <Toast message={error} isSuccess={false} />}
    </div>
  )
}

export default Post



Nom du fichier: ./app/components/business/ReportModalPost.jsx
Contenu:
import React, { useState } from "react"
import Modal from "../common/Modal.jsx"
import Toast from "../common/Toast.jsx"
import useAppContext from "@/app/hooks/useContext.jsx"
import { CheckIcon } from "@heroicons/react/24/outline"

const ReportModal = ({ isOpen, onClose, postId }) => {
  const {
    state: { session },
    action: { postReportPost }
  } = useAppContext()

  const [selectedOption, setSelectedOption] = useState("")
  const [error, setError] = useState(null)
  const [isSubmitted, setIsSubmitted] = useState(false)
  const [toast, setToast] = useState({ message: "", isSuccess: true })

  const showToast = (message, isSuccess) => {
    setToast({ message, isSuccess })
  }

  const handleSubmit = async event => {
    event.preventDefault()

    try {
      const [error, response] = await postReportPost({
        postId,
        userId: session.id,
        reason: selectedOption
      })

      if (error) {
        setError(response.message)
        showToast(response.message, false)
      } else {
        setIsSubmitted(true)
        showToast("Report submitted successfully!", true)
      }
    } catch (err) {
      const errorMessage = "Failed to submit report"
      setError(errorMessage)
      showToast(errorMessage, false)
    }
  }

  return (
    <Modal isOpen={isOpen} onClose={onClose} title="What kind of problems do you report?">
      {toast.message && <Toast message={toast.message} isSuccess={toast.isSuccess} />}
      {!isSubmitted ? (
        <form onSubmit={handleSubmit}>
          <div className="flex flex-col space-y-4">
            {[
              "Hate",
              "Inappropriate behavior and harassment",
              "Violent speech",
              "Sensitive or inconvenient media",
              "Identity theft",
              "Violent and hateful entities",
              "Spam",
              "I just don't like that"
            ].map(option => (
              <label key={option} className="inline-flex items-center">
                <input
                  type="radio"
                  name="report"
                  value={option}
                  onChange={e => setSelectedOption(e.target.value)}
                  className="form-radio"
                />
                <span className="ml-2">{option}</span>
              </label>
            ))}
          </div>
          {error && <div className="text-red-500 mt-2">{error}</div>}
          <div className="mt-4 flex justify-center">
            <button
              type="submit"
              className={`px-4 py-2 text-white rounded ${
                selectedOption ? "bg-green-500 hover:bg-green-700" : "bg-green-300 cursor-not-allowed opacity-50"
              }`}
              disabled={!selectedOption}
            >
              Send the report
            </button>
          </div>
        </form>
      ) : (
        <div className="text-center p-4 text-green-500">
          <CheckIcon className="h-10 w-10 text-green-500 mx-auto" />
          Thank you for helping us improve Instamint for the benefit of all.
        </div>
      )}
    </Modal>
  )
}

export default ReportModal



Nom du fichier: ./app/components/business/TabPost.jsx
Contenu:
import React from "react"

const Tab = ({ title, isActive, onClick }) => (
  <button
    className={`px-4 py-2 pt-4 font-semibold text-sm ${isActive ? "text-green-500 border-b-4 border-green-500" : "text-gray-500"}`}
    onClick={onClick}
  >
    {title}
  </button>
)

export default Tab



Nom du fichier: ./app/components/business/TeabagCard.jsx
Contenu:
import { UsersIcon } from "@heroicons/react/24/solid"
import Image from "next/image"

const TeabagCard = ({ teabag }) => {
  return (
    <div className="w-full mb-4">
      <div className="bg-slate-100 flex rounded-lg p-4 items-center hover:bg-slate-200 transition duration-300 px-6 lg:px-10 md:h-32">
        {teabag.image ? (
          <div className="w-16 h-16">
            {/* I have a warning in the console, I didn't find much information, it seems that it is due to a recent update of Next. https://github.com/vercel/next.js/issues/65161 I'll skip for now because we have no time*/}
            <Image src={teabag.imageBucket} alt="logo" width={42} height={42} className="rounded-md w-full h-full" />
          </div>
        ) : (
          <div className="w-16 h-16 bg-gray-300 rounded-md"></div>
        )}
        <div className="ml-3 flex-grow">
          <div className="flex justify-between items-center">
            <a className="text-black font-bold">{teabag.name}</a>
            <div className="flex items-center">
              <a className="text-gray-600 text-md mr-1">{teabag.userCount}</a>
              <UsersIcon width={16} />
            </div>
          </div>
          <p className="text-gray-600 text-sm md:text-base line-clamp-3">{teabag.description}</p>
        </div>
      </div>
    </div>
  )
}

export default TeabagCard



Nom du fichier: ./app/components/common/Button.jsx
Contenu:
import React from "react"

const Button = ({ text, onClick, type, className, ...props }) => (
  <button
    type={type}
    onClick={onClick}
    className={`bg-blue-500 hover:bg-blue-700 text-white font-bold px-3 py-2 rounded focus:outline-none focus:shadow-outline ${className}`}
    {...props}
  >
    {text}
  </button>
)

export default Button



Nom du fichier: ./app/components/common/CheckboxField.jsx
Contenu:
import { Field } from "formik"

const CheckboxField = ({ id, name, label, ...props }) => (
  <div className="mb-4 flex items-center">
    <label htmlFor={id} className="block text-gray-700 font-bold mr-2">
      {label}
    </label>
    <Field type="checkbox" id={id} name={name} className="leading-tight" {...props} />
  </div>
)

export default CheckboxField



Nom du fichier: ./app/components/common/FileInputField.jsx
Contenu:
const FileInputField = ({ name, handleImageChange }) => (
  <div className="mb-4">
    <label htmlFor={name} className="block text-gray-700 font-bold mb-2">
      Upload Image
    </label>
    <input
      id={name}
      name={name}
      type="file"
      onChange={handleImageChange}
      className="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline"
    />
  </div>
)

export default FileInputField



Nom du fichier: ./app/components/common/Footer.jsx
Contenu:
import React from "react"
import { HomeIcon, MagnifyingGlassIcon, UserGroupIcon, UserCircleIcon } from "@heroicons/react/24/outline"
import {
  HomeIcon as HomeIconSolid,
  MagnifyingGlassIcon as MagnifyingGlassIconSolid,
  UserGroupIcon as UserGroupIconSolid,
  UserCircleIcon as UserCircleIconSolid
} from "@heroicons/react/24/solid"
import { useRouter } from "next/router"
import useAppContext from "../../hooks/useContext"

const Footer = ({ toggleSearch }) => {
  const router = useRouter()
  const { state } = useAppContext()
  const { session } = state

  const navigate = page => {
    router.push(`/${page}`)
  }

  const navigateToProfile = () => {
    if (session?.id) {
      router.push(`/profile/${session.id}`)
    } else {
      router.push("/login")
    }
  }

  return (
    <footer className="fixed inset-x-0 bottom-0 bg-white border-t border-gray-200">
      <div className="flex justify-evenly items-center max-w-2xl mx-auto p-5">
        <button onClick={() => navigate("home")}>
          {router.pathname === "/home" ? (
            <HomeIconSolid className="h-7 w-7 text-green-500" />
          ) : (
            <HomeIcon className="h-7 w-7 text-gray-500" />
          )}
        </button>
        <button onClick={toggleSearch}>
          {router.pathname === "/search" ? (
            <MagnifyingGlassIconSolid className="h-7 w-7 text-green-500" />
          ) : (
            <MagnifyingGlassIcon className="h-7 w-7 text-gray-500" />
          )}
        </button>
        <button onClick={() => navigate("groups")}>
          {router.pathname === "/groups" ? (
            <UserGroupIconSolid className="h-7 w-7 text-green-500" />
          ) : (
            <UserGroupIcon className="h-7 w-7 text-gray-500" />
          )}
        </button>
        <button onClick={navigateToProfile}>
          {router.pathname.startsWith("/profile") ? (
            <UserCircleIconSolid className="h-7 w-7 text-green-500" />
          ) : (
            <UserCircleIcon className="h-7 w-7 text-gray-500" />
          )}
        </button>
      </div>
    </footer>
  )
}

export default Footer



Nom du fichier: ./app/components/common/FormButton.jsx
Contenu:
const FormButton = ({ text, ...props }) => (
  <button
    type="submit"
    className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
    {...props}
  >
    {text}
  </button>
)

export default FormButton



Nom du fichier: ./app/components/common/Header.jsx
Contenu:
import React from "react"
import Image from "next/image"

const Header = ({ logoUrl, altText }) => {
  return (
    <header className="flex justify-between items-center pl-4 pr-4">
      <Image src={logoUrl} alt={altText} width={100} height={100} />
    </header>
  )
}

export default Header



Nom du fichier: ./app/components/common/InputField.jsx
Contenu:
import React from "react"
import { useField } from "formik"

const InputField = ({ label, ...props }) => {
  const [field, meta] = useField(props.name)

  return (
    <div className="mb-4">
      <label htmlFor={props.name} className="block text-gray-700 font-bold mb-4">
        {label}
      </label>
      <input
        {...field}
        {...props}
        className={`shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline ${
          meta.error && meta.touched ? "border-red-500" : ""
        }`}
      />
    </div>
  )
}

export default InputField



Nom du fichier: ./app/components/common/Modal.jsx
Contenu:
import React from "react"

const Modal = ({ isOpen, onClose, title, children }) => {
  if (!isOpen) {
    return null
  }

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center overflow-x-hidden overflow-y-auto outline-none focus:outline-none">
      <div className="relative mx-auto my-6">
        <div className="relative bg-white border-2 border-gray-300 shadow-md rounded-lg outline-none focus:outline-none">
          <div className="flex items-start justify-between p-5 border-b border-solid border-gray-300 rounded-t">
            <h3 className="text-lg font-semibold">{title}</h3>
            <button
              className="p-1 ml-auto bg-transparent border-0 text-black float-right text-3xl leading-none font-semibold outline-none focus:outline-none"
              onClick={onClose}
            >
              <span className="text-black h-6 w-6 text-2xl block outline-none focus:outline-none">×</span>
            </button>
          </div>
          <div className="p-6">{children}</div>
        </div>
      </div>
    </div>
  )
}

export default Modal



Nom du fichier: ./app/components/common/SearchBar.jsx
Contenu:
import React, { useState } from "react"
import { useRouter } from "next/router"
import { MagnifyingGlassIcon as MagnifyingGlassIconSolid } from "@heroicons/react/24/solid"
import useAppContext from "@/app/hooks/useContext.jsx"

const Search = ({ toggleSearch }) => {
  const [query, setQuery] = useState("")
  const [suggestions, setSuggestions] = useState([])
  const {
    state: { session },
    action: { getUserProfile }
  } = useAppContext()
  const router = useRouter()

  const handleSearch = async e => {
    const { value } = e.target
    setQuery(value)

    if (!session) {
      return
    }

    if (value.length > 0) {
      try {
        const response = await getUserProfile({ search: value })

        const [error, users] = response

        if (error) {
          throw new Error(error)
        }

        setSuggestions(users)
      } catch (err) {
        setSuggestions([])
      }
    } else {
      setSuggestions([])
    }
  }

  const handleProfileClick = userId => {
    toggleSearch()
    router.push(`/user/${userId}`)
  }

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 backdrop-filter backdrop-blur-lg">
      <div className="relative max-w-md mx-auto bg-white rounded-lg z-50" style={{ width: "80%" }}>
        <div className="flex items-center bg-gray-200 p-2 rounded">
          <MagnifyingGlassIconSolid className="h-6 w-6 text-gray-500" />
          <input
            type="text"
            value={query}
            onChange={handleSearch}
            className="bg-gray-200 flex-1 ml-2 p-1 outline-none"
            placeholder="Search users..."
          />
        </div>
        {suggestions.length > 0 && (
          <div className="absolute top-full mt-1 w-full bg-white shadow-lg rounded z-50">
            {suggestions.map(user => (
              <div
                key={user.id}
                className="flex items-center p-2 border-b last:border-b-0 cursor-pointer"
                onClick={() => handleProfileClick(user.id)}
              >
                <img src={user.profileImage} alt={user.username} className="h-8 w-8 rounded-full" />
                <span className="ml-2">{user.username}</span>
              </div>
            ))}
          </div>
        )}
      </div>
      <div className="fixed inset-0 z-40" onClick={toggleSearch}></div>
    </div>
  )
}

export default Search



Nom du fichier: ./app/components/common/TextAreaField.jsx
Contenu:
const TextAreaField = ({ name, placeholder, errors, touched, ...props }) => (
  <div className="mb-4">
    <label htmlFor={name} className="block text-gray-700 font-bold mb-2">
      {placeholder}
    </label>
    <textarea
      id={name}
      name={name}
      placeholder={placeholder}
      className={`shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline ${
        errors[name] && touched[name] ? "border-red-500" : ""
      }`}
      {...props}
    />
  </div>
)

export default TextAreaField



Nom du fichier: ./app/components/common/Toast.jsx
Contenu:
import React, { useState, useEffect } from "react"

const Toast = ({ message, isSuccess }) => {
  const [isVisible, setIsVisible] = useState(true)

  useEffect(() => {
    const timer = setTimeout(() => {
      setIsVisible(false)
    }, 3000)

    return () => clearTimeout(timer)
  }, [])

  return (
    <div
      className={`fixed bottom-4 left-1/2 transform -translate-x-1/2 p-4 rounded-lg ${
        isSuccess ? "bg-green-500" : "bg-red-500"
      } text-white z-50 transition-opacity duration-500 ${isVisible ? "opacity-100" : "opacity-0"}`}
    >
      {message}
    </div>
  )
}

export default Toast



Nom du fichier: ./app/components/common/UserList.jsx
Contenu:
const UserList = ({ userEmails, handleRemoveUser, ...props }) => (
  <div className="mb-4 border rounded p-2 max-h-20 overflow-y-auto" {...props}>
    {userEmails.map((email, index) => (
      <div key={index} className="flex items-center mb-2">
        <div className="text-gray-700 mr-2">{email}</div>
        <button
          type="button"
          onClick={() => {
            handleRemoveUser(index)
          }}
          className="text-red-500 font-bold"
        >
          &#10006;
        </button>
      </div>
    ))}
  </div>
)

export default UserList



Nom du fichier: ./app/components/form/AddTeabag.jsx
Contenu:
import React, { useState } from "react"
import { Formik, Form } from "formik"
import { z, ZodError } from "zod"
import InputField from "../common/InputField"
import TextAreaField from "../common/TextAreaField"
import FileInputField from "../common/FileInputField"
import CheckboxField from "../common/CheckboxField"
import FormButton from "../common/FormButton"
import Button from "../common/Button"
import UserList from "../common/UserList"
import Toast from "../common/Toast"

const validationSchema = z.object({
  name: z.string().nonempty("Teabag name is required"),
  description: z.string(),
  newEmail: z.string().email("Invalid email format")
})

const AddTeabagForm = ({ onSubmit, closeModal, idUser, createTeabagFunction }) => {
  const [userEmails, setUserEmails] = useState([])
  const [selectedImage, setSelectedImage] = useState(null)
  const [error, setError] = useState(null)

  const handleAddUser = email => {
    setUserEmails(prevEmails => [...prevEmails, email])
  }

  const handleRemoveUser = index => {
    setUserEmails(prevEmails => prevEmails.filter((_, i) => i !== index))
  }

  const handleImageChange = event => {
    setSelectedImage(event.target.files[0])
  }

  const validateForm = values => {
    try {
      validationSchema.parse(values)
    } catch (error) {
      if (error instanceof ZodError) {
        return error.errors.reduce((acc, curr) => {
          if (curr.path[0] === "newEmail" && values.newEmail === "") {
            return acc
          }

          return {
            ...acc,
            [curr.path[0]]: curr.message
          }
        }, {})
      }
    }
  }

  const handleSubmit = async (values, { resetForm }) => {
    try {
      const formData = new FormData()
      formData.append("name", values.name)
      formData.append("description", values.description)
      formData.append("private", String(values.private))
      formData.append("invitedEmailsUsers", JSON.stringify(userEmails))

      if (selectedImage) {
        formData.append("image", selectedImage)
      }

      const [error, data] = await createTeabagFunction({ idUser, formData })

      if (error) {
        setError(error)

        return
      }

      onSubmit(data)
      resetForm()
      setUserEmails([])
      setSelectedImage(null)
      closeModal()
    } catch (error) {
      setError(error)
    }
  }

  return (
    <div>
      {error && <Toast message={error.message} isSuccess={false} />}
      <Formik
        initialValues={{
          name: "",
          description: "",
          private: false,
          newEmail: ""
        }}
        validate={validateForm}
        onSubmit={handleSubmit}
      >
        {({ values, errors, touched }) => (
          <Form className="w-full">
            <InputField
              name="name"
              placeholder="Group name"
              type="text"
              errors={errors}
              touched={touched}
              label="Group name"
            />
            <TextAreaField name="description" placeholder="Description group" errors={errors} touched={touched} />
            <div className="flex items-center justify-between">
              <InputField
                name="newEmail"
                placeholder="Enter email"
                type="email"
                errors={errors}
                touched={touched}
                label="Invite friends"
              />
              <Button
                text="Add"
                type="button"
                onClick={() => {
                  if (values.newEmail) {
                    handleAddUser(values.newEmail)
                  }
                }}
                className="mt-6"
              />
            </div>
            {userEmails.length > 0 && <UserList userEmails={userEmails} handleRemoveUser={handleRemoveUser} />}
            {errors.newEmail && touched.newEmail && <div className="text-red-500">{errors.newEmail}</div>}
            <FileInputField name="image" handleImageChange={handleImageChange} />
            <CheckboxField id="private" name="private" label="Private" />
            <FormButton text="Add Teabag" />
          </Form>
        )}
      </Formik>
    </div>
  )
}

export default AddTeabagForm



Nom du fichier: ./app/components/profile/PasswordChangeForm.jsx
Contenu:
import React, { useState } from "react"

const PasswordChangeForm = ({ passwords, handleChange, handleSubmit, handleCancel, loading }) => {
  const [error, setError] = useState("")

  const validatePassword = password => {
    const passwordRegex = /^(?=.*[A-Z])(?=.*[!@#$%^&*])(?=.{8,})/

    return passwordRegex.test(password)
  }

  const handleFormSubmit = e => {
    e.preventDefault()

    if (!validatePassword(passwords.newPassword)) {
      setError("Password must be at least 8 characters long, contain 1 uppercase letter and 1 symbol.")

      return
    }

    setError("")
    handleSubmit(e)
  }

  return (
    <form onSubmit={handleFormSubmit} className="space-y-4">
      {error && <div className="text-red-500">{error}</div>}
      <div className="flex flex-col">
        <label htmlFor="oldPassword" className="text-sm font-medium text-gray-700">
          Old Password:
        </label>
        <input
          id="oldPassword"
          type="password"
          name="oldPassword"
          value={passwords.oldPassword}
          onChange={handleChange}
          className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
          required
        />
      </div>
      <div className="flex flex-col">
        <label htmlFor="newPassword" className="text-sm font-medium text-gray-700">
          New Password:
        </label>
        <input
          id="newPassword"
          type="password"
          name="newPassword"
          value={passwords.newPassword}
          onChange={handleChange}
          className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
          required
        />
      </div>
      <div className="flex flex-col">
        <label htmlFor="confirmPassword" className="text-sm font-medium text-gray-700">
          Confirm New Password:
        </label>
        <input
          id="confirmPassword"
          type="password"
          name="confirmPassword"
          value={passwords.confirmPassword}
          onChange={handleChange}
          className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
          required
        />
      </div>
      <div className="flex justify-between">
        <button
          type="submit"
          disabled={loading}
          className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50"
        >
          {loading ? "Updating..." : "Change Password"}
        </button>
        <button
          type="button"
          onClick={handleCancel}
          className="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded focus:outline-none focus:ring-2 focus:ring-gray-500"
        >
          Cancel
        </button>
      </div>
    </form>
  )
}

export default PasswordChangeForm



Nom du fichier: ./app/components/profile/PasswordChangeSuccessMessage.jsx
Contenu:
import React from "react"

const PasswordChangeSuccessMessage = ({ countdown }) => (
  <>
    <p className="mb-6 text-gray-700">
      Your password has been updated. You will be redirected to the login page in {countdown} seconds.
    </p>
    <div className="relative w-full h-4 bg-gray-200 rounded">
      <div
        className="absolute top-0 left-0 h-4 bg-blue-500 rounded transition-width duration-1000"
        style={{ width: `${(5 - countdown) * 20}%` }}
      ></div>
    </div>
  </>
)

export default PasswordChangeSuccessMessage



Nom du fichier: ./app/components/profile/ProfileContent.jsx
Contenu:
import React from "react"
import Post from "@/app/components/business/Post.jsx"
import { useRouter } from "next/router"

const formatNumber = num => {
  if (num >= 1000000000) {
    return (num / 1000000000).toFixed(1) + " B"
  } else if (num >= 1000000) {
    return (num / 1000000).toFixed(1) + " M"
  } else if (num >= 1000) {
    return (num / 1000).toFixed(1) + " K"
  }

  return num.toString()
}

const ProfileContent = ({ user, posts, readOnly }) => {
  const postsCount = posts.length
  const router = useRouter()

  return (
    <div className="mt-4 px-4 flex flex-col items-start" style={{ padding: "10px" }}>
      <div className="flex w-full">
        <div className="flex flex-col items-start mr-8">
          <img src={user.profileImage} alt="Profile" className="h-24 w-24 rounded-full border-4 border-white" />
        </div>
        <div className="flex-grow flex justify-around mt-6">
          <div className="flex flex-col items-center">
            <span className="font-bold text-lg" title={postsCount}>
              {formatNumber(postsCount)}
            </span>
            <span className="text-sm text-gray-600">Posts</span>
          </div>
          <div className="flex flex-col items-center">
            <span className="font-bold text-lg" title={user.following}>
              {formatNumber(user.following)}
            </span>
            <span className="text-sm text-gray-600">Following</span>
          </div>
          <div className="flex flex-col items-center">
            <span className="font-bold text-lg" title={user.followers}>
              {formatNumber(user.followers)}
            </span>
            <span className="text-sm text-gray-600">Followers</span>
          </div>
        </div>
      </div>
      <div className="flex flex-col items-start w-full">
        <div className="mt-2">
          <div className="text-xl font-bold">{user.username}</div>
          <div className="text-sm text-gray-600">{user.bio || "No bio provided."}</div>
        </div>
        <div className="mt-4 flex justify-center w-full space-x-2">
          {!readOnly ? (
            <>
              <button
                className="bg-gray-300 text-gray-800 py-2 px-4 rounded"
                onClick={() => router.push("/profile/editProfile")}
              >
                Edit Profile
              </button>
              <button className="bg-gray-300 text-gray-800 py-2 px-4 rounded">Share Profile</button>
            </>
          ) : (
            <>
              <button className="text-white py-2 px-4 rounded" style={{ backgroundColor: "#16502d" }}>
                Follow
              </button>
              <button className="bg-gray-300 text-gray-800 py-2 px-4 rounded">Message</button>
            </>
          )}
        </div>
      </div>
      <hr className="w-full mt-4" />
      <div className="mt-4 w-full">
        {posts.map(post => (
          <Post
            key={post.id}
            postId={post.id}
            username={user.username}
            createdAt={post.createdAt}
            description={post.description}
            imageUrl={post.imageUrl}
            profileImage={user.profileImage}
          />
        ))}
      </div>
    </div>
  )
}

export default ProfileContent



Nom du fichier: ./app/components/profile/ProfileHeader.jsx
Contenu:
import React, { useState } from "react"
import { useRouter } from "next/router"
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome"
import { faBars } from "@fortawesome/free-solid-svg-icons"

const ProfileHeader = ({ user, readOnly }) => {
  const [showMenu, setShowMenu] = useState(false)
  const router = useRouter()

  const toggleMenu = () => {
    setShowMenu(!showMenu)
  }

  const handleDeleteAccountRedirect = () => {
    router.push(`/profile/deleteProfile`)
  }

  return (
    <div className="w-full h-56 bg-cover bg-center relative" style={{ backgroundImage: `url(${user.coverImage})` }}>
      <div className="absolute top-4 left-4">
        <img src="/images/logo-Instamint.png" alt="Company Logo" className="h-29 w-14" />
      </div>
      {!readOnly && (
        <div className="absolute top-4 right-4">
          <button
            onClick={toggleMenu}
            className="p-2 text-white bg-gray-800 bg-opacity-75 rounded-full hover:bg-opacity-100 transition-opacity duration-300"
          >
            <FontAwesomeIcon icon={faBars} size="lg" />
          </button>
          {showMenu && (
            <div className="absolute right-0 mt-12 bg-white rounded shadow-lg w-48">
              <ul className="text-gray-700">
                <li
                  className="px-4 py-2 hover:bg-gray-100 cursor-pointer"
                  onClick={() => router.push("/profile/changePassword")}
                >
                  Change Password
                </li>
                <li className="px-4 py-2 hover:bg-gray-100 cursor-pointer" onClick={handleDeleteAccountRedirect}>
                  Delete Account
                </li>
                <li
                  className="px-4 py-2 hover:bg-gray-100 cursor-pointer"
                  onClick={() => router.push("/logout/logout")}
                >
                  Logout
                </li>
              </ul>
            </div>
          )}
        </div>
      )}
    </div>
  )
}

export default ProfileHeader



Nom du fichier: ./app/components/profile/delete/DeleteProfileCountdown.jsx
Contenu:
// eslint-disable-next-line no-unused-vars
import React, { useEffect } from "react"

// eslint-disable-next-line no-unused-vars
const DeleteProfileCountdown = ({ countdown, setCountdown }) => {
  useEffect(() => {
    const timer = setInterval(() => {
      setCountdown(prev => prev - 1)
    }, 1000)

    return () => clearInterval(timer)
  }, [setCountdown])

  return null
}

export default DeleteProfileCountdown



Nom du fichier: ./app/components/profile/delete/DeleteProfileForm.jsx
Contenu:
import React, { useState } from "react"
import Button from "@/app/components/common/Button"
import Toast from "@/app/components/common/Toast"

const DeleteProfileForm = ({ onDelete, loading, message, success, router, session }) => {
  const [password, setPassword] = useState("")

  const handleDelete = () => {
    onDelete(password)
  }

  return (
    <div className="flex flex-col items-center w-full p-4">
      <h1 className="text-2xl font-bold text-red-600 mb-4">Delete Account</h1>
      {message && <Toast message={message} isSuccess={success} />}
      <p className="mb-6 text-gray-700">Are you sure you want to delete your account? This action cannot be undone.</p>
      <input
        type="password"
        placeholder="Enter your password"
        value={password}
        onChange={e => setPassword(e.target.value)}
        className="mb-4 p-2 border border-gray-300 rounded w-full focus:outline-none focus:ring-2 focus:ring-red-600"
      />
      <div className="flex justify-between w-full">
        <Button
          onClick={handleDelete}
          loading={loading}
          text="Delete Account"
          className="bg-red-500 hover:bg-red-600"
        />
        <Button
          onClick={() => router.push(`/profile/${session.id}`)}
          text="Cancel"
          className="bg-gray-500 hover:bg-gray-600"
        />
      </div>
    </div>
  )
}

export default DeleteProfileForm



Nom du fichier: ./app/components/profile/delete/DeleteProfileMessage.jsx
Contenu:
import React from "react"

const DeleteProfileMessage = ({ countdown }) => (
  <>
    <p className="mb-6 text-gray-700">
      Your account has been deleted. You will be redirected to the login page in {countdown} seconds.
    </p>
    <div className="relative w-full h-4 bg-gray-200 rounded">
      <div
        className="absolute top-0 left-0 h-4 bg-red-500 rounded transition-width duration-1000"
        style={{ width: `${(5 - countdown) * 20}%` }}
      ></div>
    </div>
  </>
)

export default DeleteProfileMessage



Nom du fichier: ./app/components/profile/edit/Countdown.jsx
Contenu:
import React, { useEffect } from "react"
import { useRouter } from "next/router"

const Countdown = ({ countdown, setCountdown, userId }) => {
  const router = useRouter()

  useEffect(() => {
    const countdownInterval = setInterval(() => {
      setCountdown(prevCountdown => prevCountdown - 1)
    }, 1000)

    setTimeout(() => {
      clearInterval(countdownInterval)
      router.push(`/profile/${userId}`)
    }, countdown * 1000)

    return () => clearInterval(countdownInterval)
  }, [countdown, setCountdown, router, userId])

  return (
    <>
      <p className="mb-6 text-gray-700">
        Your profile has been updated. You will be redirected to your profile page in {countdown} seconds
      </p>
      <div className="relative w-full h-4 bg-gray-200 rounded">
        <div
          className="absolute top-0 left-0 h-4 bg-blue-500 rounded transition-width duration-1000"
          style={{ width: `${(5 - countdown) * 20}%` }}
        ></div>
      </div>
    </>
  )
}

export default Countdown



Nom du fichier: ./app/components/profile/edit/CoverImageOptions.jsx
Contenu:
import React from "react"

const CoverImageOptions = ({ option, setOption }) => (
  <div className="flex flex-col mb-4">
    <label className="text-sm font-medium text-gray-700 mb-2">Cover Image:</label>
    <div className="flex items-center justify-between mb-2">
      {["current", "random", "default"].map(opt => (
        <div className="flex items-center" key={opt}>
          <input
            type="radio"
            name="coverImageOption"
            value={opt}
            checked={option === opt}
            onChange={() => setOption(opt)}
            className="hidden"
            id={`cover-${opt}`}
          />
          <label htmlFor={`cover-${opt}`} className="flex items-center cursor-pointer">
            <span
              className={`mr-2 w-4 h-4 inline-block rounded-full border-2 ${option === opt ? "border-blue-500" : "border-gray-300"} flex items-center justify-center`}
            >
              {option === opt && <span className="w-2 h-2 bg-blue-500 rounded-full inline-block"></span>}
            </span>
            <span className="text-sm text-gray-700">{opt.charAt(0).toUpperCase() + opt.slice(1)}</span>
          </label>
        </div>
      ))}
    </div>
  </div>
)

export default CoverImageOptions



Nom du fichier: ./app/components/profile/edit/EditProfileForm.jsx
Contenu:
import React from "react"
import ProfileImageOptions from "./ProfileImageOptions"
import CoverImageOptions from "./CoverImageOptions"
import Message from "./Message"

const EditProfileForm = ({
  user,
  handleInputChange,
  handleSubmit,
  loading,
  message,
  profileImageOption,
  setProfileImageOption,
  coverImageOption,
  setCoverImageOption,
  handleCancel
}) => (
  <>
    {message && <Message type={message.type} text={message.text} />}
    <form onSubmit={handleSubmit} className="space-y-4">
      <div className="flex flex-col">
        <label htmlFor="username" className="text-sm font-medium text-gray-700">
          Username:
        </label>
        <input
          id="username"
          type="text"
          name="username"
          value={user.username}
          onChange={handleInputChange}
          className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
          required
        />
      </div>
      <div className="flex flex-col">
        <label htmlFor="bio" className="text-sm font-medium text-gray-700">
          Bio:
        </label>
        <textarea
          id="bio"
          name="bio"
          value={user.bio}
          onChange={handleInputChange}
          className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
          required
        />
      </div>
      <ProfileImageOptions option={profileImageOption} setOption={setProfileImageOption} />
      <CoverImageOptions option={coverImageOption} setOption={setCoverImageOption} />
      <div className="flex justify-between">
        <button
          type="submit"
          disabled={loading}
          className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50"
        >
          {loading ? "Updating..." : "Update Profile"}
        </button>
        <button
          type="button"
          onClick={handleCancel}
          className="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded focus:outline-none focus:ring-2 focus:ring-gray-500"
        >
          Cancel
        </button>
      </div>
    </form>
  </>
)

export default EditProfileForm



Nom du fichier: ./app/components/profile/edit/Message.jsx
Contenu:
import React from "react"

const Message = ({ type, text }) => {
  const messageTypeClass = type === "error" ? "bg-red-100 text-red-700" : "bg-green-100 text-green-700"

  return (
    <div className={`p-4 mb-4 text-sm ${messageTypeClass} rounded`} role="alert">
      {text}
    </div>
  )
}

export default Message



Nom du fichier: ./app/components/profile/edit/ProfileImageOptions.jsx
Contenu:
import React from "react"

const ProfileImageOptions = ({ option, setOption }) => (
  <div className="flex flex-col mb-4">
    <label className="text-sm font-medium text-gray-700 mb-2">Profile Image:</label>
    <div className="flex items-center justify-between mb-2">
      {["current", "random", "default"].map(opt => (
        <div className="flex items-center" key={opt}>
          <input
            type="radio"
            name="profileImageOption"
            value={opt}
            checked={option === opt}
            onChange={() => setOption(opt)}
            className="hidden"
            id={`profile-${opt}`}
          />
          <label htmlFor={`profile-${opt}`} className="flex items-center cursor-pointer">
            <span
              className={`mr-2 w-4 h-4 inline-block rounded-full border-2 ${option === opt ? "border-blue-500" : "border-gray-300"} flex items-center justify-center`}
            >
              {option === opt && <span className="w-2 h-2 bg-blue-500 rounded-full inline-block"></span>}
            </span>
            <span className="text-sm text-gray-700">{opt.charAt(0).toUpperCase() + opt.slice(1)}</span>
          </label>
        </div>
      ))}
    </div>
  </div>
)

export default ProfileImageOptions



Nom du fichier: ./app/hooks/useContext.jsx
Contenu:
import config from "@/app/api/config.mjs"
import createAPIClient from "@/app/api/createAPIClient.mjs"
import { createContext, useContext, useEffect, useState } from "react"
import { decode } from "hono/jwt"
import createUserTeabagService from "@/app/services/teabags/teabagUserCreate.mjs"
import getUserTeabagsService from "@/app/services/teabags/teabagsUserGet.mjs"
import getForyouPostService from "@/app/services/posts/foryouPostGet.mjs"
import getLikesPostService from "@/app/services/posts/likesPostGet.mjs"
import getLikedPostService from "@/app/services/posts/likedPostGet.mjs"
import deleteLikePostService from "@/app/services/posts/likePostDelete.mjs"
import postLikePostService from "@/app/services/posts/likePostPost.mjs"
import getSubscribedPostService from "@/app/services/posts/subscribedPostGet.mjs"
import postReportPostService from "@/app/services/posts/reportPostPost.mjs"
import getUserProfileService from "@/app/services/profile/getUserProfile.mjs"
import updateUserProfileService from "@/app/services/profile/updateUserProfile.mjs"
import changeUserPasswordService from "@/app/services/profile/changeUserPassword.mjs"
import deleteUserProfileService from "@/app/services/profile/deleteUserProfile.mjs"
import getUserPostsService from "@/app/services/posts/getUserPosts.mjs"
import deletePostService from "@/app/services/posts/deletePost.mjs"

const AppContext = createContext()

export const AppContextProvider = props => {
  const { isPublicPage, ...otherProps } = props
  const [session, setSession] = useState(null)
  const [jwt, setJWT] = useState(null)
  const [isLoading, setIsLoading] = useState(true)

  const apiClients = {}
  for (const apiKey in config) {
    apiClients[apiKey] = createAPIClient({ jwt, apiKey })
  }

  useEffect(() => {
    const storedJwt = localStorage.getItem("instamint") || localStorage.getItem("token")

    if (!storedJwt) {
      setIsLoading(false)

      return
    }

    try {
      const { payload } = decode(storedJwt)

      if (payload && payload.id) {
        setSession(payload)
        setJWT(storedJwt)
        localStorage.setItem("session", JSON.stringify(payload))
      } else {
        localStorage.removeItem("instamint")
        localStorage.removeItem("token")
        localStorage.removeItem("session")
      }
    } catch (error) {
      localStorage.removeItem("instamint")
      localStorage.removeItem("token")
      localStorage.removeItem("session")
    } finally {
      setIsLoading(false)
    }
  }, [])

  useEffect(() => {
    const storedSession = localStorage.getItem("session")

    if (storedSession) {
      setSession(JSON.parse(storedSession))
    }
  }, [])

  const getUserTeabags = getUserTeabagsService({ apiClients })
  const createUserTeabag = createUserTeabagService({ apiClients })
  const getForyouPost = getForyouPostService({ apiClients })
  const getSubscribedPost = getSubscribedPostService({ apiClients })
  const getLikesPost = getLikesPostService({ apiClients })
  const getLikedPost = getLikedPostService({ apiClients })
  const deleteLikePost = deleteLikePostService({ apiClients })
  const postLikePost = postLikePostService({ apiClients })
  const postReportPost = postReportPostService({ apiClients })
  const deletePost = deletePostService({ apiClients })
  const getUserProfile = getUserProfileService({ apiClients })
  const updateUserProfile = updateUserProfileService({ apiClients })
  const changePassword = changeUserPasswordService({ apiClients })
  const deleteUserProfile = deleteUserProfileService({ apiClients })
  const getUserPosts = getUserPostsService({ apiClients })

  const appContextValue = {
    state: { session },
    action: {
      getUserTeabags,
      createUserTeabag,
      getUserProfile,
      updateUserProfile,
      changePassword,
      deleteUserProfile,
      getForyouPost,
      getSubscribedPost,
      getLikesPost,
      getLikedPost,
      deleteLikePost,
      postLikePost,
      getUserPosts,
      postReportPost,
      deletePost
    }
  }

  if (isLoading) {
    return (
      <div className="fixed inset-0 flex items-center justify-center bg-white text-4xl font-bold">
        <span className="animate-bounce">Loading...</span>
      </div>
    )
  }

  if (!isPublicPage && session === null) {
    return (
      <div className="fixed inset-0 flex items-center justify-center bg-white text-4xl font-bold">
        <span className="animate-bounce">Loading...</span>
      </div>
    )
  }

  return <AppContext.Provider value={appContextValue} {...otherProps} />
}

const useAppContext = () => useContext(AppContext)

export default useAppContext



Nom du fichier: ./app/hooks/usePostInteractions.jsx
Contenu:
import { useState, useCallback, useEffect } from "react"
import useAppContext from "@/app/hooks/useContext.jsx"

const usePostInteractions = postId => {
  const {
    state: { session },
    action: { getLikedPost, getLikesPost, deleteLikePost, postLikePost }
  } = useAppContext()

  const [isLiked, setIsLiked] = useState(false)
  const [likeCount, setLikeCount] = useState(null)
  const [toast, setToast] = useState({ message: "", isSuccess: true })
  const [error, setError] = useState(null)

  const showError = message => {
    setToast({ message, isSuccess: false })
  }

  useEffect(() => {
    const fetchLikeStatus = async () => {
      try {
        const [likedError, likedResponse] = await getLikedPost({ postId, userId: session.id })
        const [likesError, likesResponse] = await getLikesPost({ postId, userId: session.id })

        if (likedError || likesError) {
          setError(likedError || likesError)
          showError(likedError || likesError)

          return
        }

        setIsLiked(likedResponse.isLiked)
        setLikeCount(likesResponse.likeCount > 0 ? likesResponse.likeCount : null)
      } catch (err) {
        setError("Failed to fetch like data")
        showError("Failed to fetch like data")
      }
    }

    fetchLikeStatus()
  }, [postId, getLikedPost, getLikesPost, session.id])

  const toggleLike = useCallback(async () => {
    try {
      if (isLiked) {
        const { error } = await deleteLikePost({ postId, userId: session.id })

        if (error) {
          setError(error)
          showError(error)

          return
        }

        setIsLiked(false)
        setLikeCount(prev => (prev > 1 ? parseInt(prev) - 1 : null))
      } else {
        const { error } = await postLikePost({ postId, userId: session.id })

        if (error) {
          setError(error)
          showError(error)

          return
        }

        setIsLiked(true)
        setLikeCount(prev => (prev != null ? parseInt(prev) + 1 : 1))
      }
    } catch (err) {
      setError("Failed to update like status")
      showError("Failed to update like status")
    }
  }, [postId, isLiked, deleteLikePost, postLikePost, session.id])

  return {
    isLiked,
    likeCount,
    toggleLike,
    error,
    toast
  }
}

export default usePostInteractions



Nom du fichier: ./app/layout/layout.jsx
Contenu:
import React, { useState } from "react"
import Footer from "../components/common/Footer"
import Search from "../components/common/SearchBar"
import { useRouter } from "next/router"

const Layout = ({ children }) => {
  const [isSearchOpen, setIsSearchOpen] = useState(false)
  const router = useRouter()
  const { pathname } = router

  const toggleSearch = () => {
    setIsSearchOpen(!isSearchOpen)
  }

  const noFooterPaths = ["/", "/login", "/register"]

  return (
    <div>
      <main>{children}</main>
      {!noFooterPaths.includes(pathname) && <Footer toggleSearch={toggleSearch} />}
      {isSearchOpen && !noFooterPaths.includes(pathname) && <Search toggleSearch={toggleSearch} />}
    </div>
  )
}

export default Layout



Nom du fichier: ./app/services/profile/changeUserPassword.mjs
Contenu:
const changeUserPassword =
  ({ apiClients }) =>
  async ({ idUser, oldPassword, newPassword }) => {
    try {
      const response = await apiClients.apiUser.put(`/api/user/${idUser}/change-password`, {
        oldPassword,
        newPassword
      })

      return [null, response.data]
    } catch (error) {
      return [error.response?.data?.message || "Failed to change password", null]
    }
  }

export default changeUserPassword



Nom du fichier: ./app/services/profile/deleteUserProfile.mjs
Contenu:
import routes from "@/app/api/routes.mjs"

const deleteUserProfile =
  ({ apiClients }) =>
  async ({ userId, password }) => {
    if (!apiClients) {
      throw new Error("apiClients is not defined yet")
    }

    const { apiUser } = apiClients

    if (!apiUser || typeof apiUser.delete !== "function") {
      throw new Error("apiUser is not defined or not a function")
    }

    userId = parseInt(userId)

    try {
      const { data } = await apiUser.delete(routes.apiUser.profile(userId), {
        data: { password }
      })

      return [null, data]
    } catch (err) {
      const error = err.response?.data?.error || "Oops. Something went wrong"
      throw new Error(Array.isArray(error) ? error.join(", ") : error)
    }
  }

export default deleteUserProfile



Nom du fichier: ./app/services/profile/getUserProfile.mjs
Contenu:
import routes from "@/app/api/routes.mjs"

const getUserProfile =
  ({ apiClients }) =>
  async ({ userId, search }) => {
    if (!apiClients) {
      throw new Error("apiClients is not defined yet")
    }

    const { apiUser } = apiClients

    if (!apiUser || typeof apiUser.get !== "function") {
      throw new Error("apiUser is not defined or not a function")
    }

    try {
      let data

      if (userId) {
        userId = parseInt(userId)

        if (isNaN(userId)) {
          throw new Error("Invalid user ID")
        }

        ;({ data } = await apiUser.get(routes.apiUser.profile(userId)))
      } else if (search) {
        ;({ data } = await apiUser.get(routes.apiUser.search(search)))
      } else {
        throw new Error("Either userId or search must be provided")
      }

      return [null, data]
    } catch (err) {
      const error = err.response?.data?.error || "Oops. Something went wrong"
      throw new Error(Array.isArray(error) ? error : [error])
    }
  }

export default getUserProfile



Nom du fichier: ./app/services/profile/updateUserProfile.mjs
Contenu:
import routes from "@/app/api/routes.mjs"

const updateUserProfile =
  ({ apiClients }) =>
  async ({ userId, userData }) => {
    if (!apiClients) {
      throw new Error("apiClients is not defined yet")
    }

    const { apiUser } = apiClients

    if (!apiUser || typeof apiUser.put !== "function") {
      throw new Error("apiUser is not defined or not a function")
    }

    userId = parseInt(userId)

    try {
      const { data } = await apiUser.put(routes.apiUser.updateProfile(userId), userData)

      return [null, data]
    } catch (err) {
      const error = err.response?.data?.error || "Oops. Something went wrong"
      throw new Error(Array.isArray(error) ? error.join(", ") : error)
    }
  }

export default updateUserProfile



Nom du fichier: ./app/services/teabags/teabagUserCreate.mjs
Contenu:
import routes from "@/app/api/routes.mjs"

const createUserTeabag =
  ({ apiClients }) =>
  async ({ idUser, formData }) => {
    if (!apiClients) {
      throw new Error("apiClients is not defined yet")
    }

    const { apiRelation } = apiClients

    if (!apiRelation || typeof apiRelation.get !== "function") {
      throw new Error("apiRelation is not defined or not a function")
    }

    idUser = parseInt(idUser)

    try {
      const { data } = await apiRelation.post(routes.apiRelation.teabags.userCreateTeabag(idUser), formData)

      return [null, data]
    } catch (err) {
      const error = err.response?.data?.error || "Oops. Something went wrong"

      throw new Error(Array.isArray(error) ? error.join(", ") : error)
    }
  }

export default createUserTeabag



Nom du fichier: ./app/services/teabags/teabagsUserGet.mjs
Contenu:
import routes from "@/app/api/routes.mjs"

const getUserTeabags =
  ({ apiClients }) =>
  async ({ userId }) => {
    if (!apiClients) {
      throw new Error("apiClients is not defined yet")
    }

    const { apiRelation } = apiClients

    if (!apiRelation || typeof apiRelation.get !== "function") {
      throw new Error("apiRelation is not defined or not a function")
    }

    userId = parseInt(userId)

    try {
      const { data } = await apiRelation.get(routes.apiRelation.teabags.userTeabags(userId))

      return [null, data]
    } catch (err) {
      const error = err.response?.data?.error || "Oops. Something went wrong"

      throw new Error[Array.isArray(error) ? error : [error]]()
    }
  }

export default getUserTeabags



Nom du fichier: ./app/styles/Home.module.css
Contenu:
@import url("https://fonts.googleapis.com/css2?family=Poetsen+One&display=swap");

.splash {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 100vh;
  width: 100%;
  background-color: white;
}

.splash img {
  margin-left: 25px;
}

.logoFadeIn {
  width: 50%;
  max-width: 200px;
  opacity: 0;
  animation: fadeIn 1.5s ease forwards;
}

.pageContainer {
  opacity: 1;
  transition: opacity 0.5s ease-out;
  height: 100%;
}

.fadeOut {
  opacity: 0;
}

.corners {
  width: 60px;
  height: 60px;
  position: relative;
  transform-origin: center;
  animation: spin 3s infinite linear;
}

.corner {
  width: 100%;
  height: 100%;
  position: absolute;

  &::before {
    display: block;
    width: 48%;
    height: 48%;
    border-radius: 0 40% 0 40%;
    background-color: #37c871;
    content: "";
  }
}

.corner--1 {
  animation: spin1 3s infinite cubic-bezier(0.785, 0.135, 0.15, 0.86);
}

.corner--2 {
  animation: spin2 3s infinite cubic-bezier(0.785, 0.135, 0.15, 0.86);
}

.corner--3 {
  animation: spin3 3s infinite cubic-bezier(0.785, 0.135, 0.15, 0.86);
}

.corner--4 {
  animation: spin4 3s infinite cubic-bezier(0.785, 0.135, 0.15, 0.86);
}

@keyframes spin1 {
  0% {
    transform: rotate(0deg);
  }
  30% {
    transform: rotate(0deg);
  }
  70% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

@keyframes spin2 {
  0% {
    transform: rotate(0deg);
  }
  30% {
    transform: rotate(270deg);
  }
  70% {
    transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

@keyframes spin3 {
  0% {
    transform: rotate(0deg);
  }
  30% {
    transform: rotate(180deg);
  }
  70% {
    transform: rotate(180deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

@keyframes spin4 {
  0% {
    transform: rotate(0deg);
  }
  30% {
    transform: rotate(90deg);
  }
  70% {
    transform: rotate(90deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

@keyframes blur {
  from {
    opacity: 1;
  }
  to {
    opacity: 0;
  }
}

@keyframes fadeIn {
  to {
    opacity: 1;
  }
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}



Nom du fichier: ./app/styles/Login.module.css
Contenu:
.pageContainer {
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
}

.pageContainer form {
  width: 90%;
}

.pageContainer form div {
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
}

.btnlogin {
  background-color: #16502d;
  width: 90%;
  border-radius: 20px;
  color: white;
  font-size: 14px;
  padding: 10px 15px 10px 15px;
  margin-top: 30px;
}

.input {
  padding: 15px;
  width: 100%;
  border-radius: 5px;
  margin: 10px;
  box-shadow: rgba(0, 0, 0, 0.35) 0px 5px 15px;
  font-size: 14px;
}

.bottomContainerLogin {
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  font-size: 12px;
  margin-top: 15px;
  width: 100%;
}

.bottomContainerLogin div {
  flex-direction: row !important;
}

.secondTextBottomContainerLogin {
  color: #16502d;
}

.logo {
  width: 20%;
  margin-bottom: 40px;
}

.passwordHint {
  font-size: 12px;
  color: gray;
  margin-top: 5px;
}

.verifiedMessage {
  color: green;
  text-align: center;
  margin-bottom: 20px;
}

.error {
  color: red;
  font-size: 12px;
  margin-top: 5px;
}



Nom du fichier: ./app/styles/globals.css
Contenu:
@tailwind base;
@tailwind components;
@tailwind utilities;
@import url("https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap");

:root {
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 214, 219, 220;
  --background-end-rgb: 255, 255, 255;
}

@media (prefers-color-scheme: dark) {
  :root {
    --foreground-rgb: 255, 255, 255;
    --background-start-rgb: 0, 0, 0;
    --background-end-rgb: 0, 0, 0;
  }
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}

* {
  font-family: "JetBrains Mono", monospace;
}

main {
  height: 100vh;
}



Nom du fichier: ./pages/_app.jsx
Contenu:
import Layout from "@/app/layout/layout.jsx"
import "@/app/styles/globals.css"
import { AppContextProvider } from "@/app/hooks/useContext.jsx"

function MyApp({ Component, pageProps }) {
  return (
    <AppContextProvider isPublicPage={Component.isPublicPage}>
      <Layout>
        <Component {...pageProps} />
      </Layout>
    </AppContextProvider>
  )
}

export default MyApp



Nom du fichier: ./pages/logout/logout.jsx
Contenu:
import { useEffect } from "react"
import { useRouter } from "next/router"

const Logout = () => {
  const router = useRouter()

  useEffect(() => {
    localStorage.removeItem("user")
    localStorage.removeItem("token")
    localStorage.removeItem("session")

    router.push("/login")
  }, [router])

  return <div>Logging out... Please wait.</div>
}

export default Logout



Nom du fichier: ./pages/profile/[id].jsx
Contenu:
import React, { useState, useEffect } from "react"
import { useRouter } from "next/router"
import ProfileHeader from "@/app/components/profile/ProfileHeader.jsx"
import ProfileContent from "@/app/components/profile/ProfileContent.jsx"
import useAppContext from "@/app/hooks/useContext.jsx"

const ProfilePage = () => {
  const [user, setUser] = useState(null)
  const [userPosts, setUserPosts] = useState([])
  const router = useRouter()
  const {
    state: { session },
    action: { getUserProfile, getUserPosts }
  } = useAppContext()

  useEffect(() => {
    if (!session) {
      router.push("/login")

      return
    }

    const fetchUserData = async () => {
      try {
        const userId = router.query.id

        if (!userId) {
          return
        }

        const [profileError, profileData] = await getUserProfile({ userId })

        if (profileError) {
          throw new Error(profileError)
        }

        setUser(profileData)

        const [postsError, postsData] = await getUserPosts({ userId })

        if (postsError) {
          throw new Error(postsError)
        }

        setUserPosts(postsData)
      } catch (err) {
        router.push("/login")
      }
    }

    fetchUserData()
  }, [session, router.query.id, getUserProfile, getUserPosts, router])

  if (!session) {
    return (
      <div className="fixed inset-0 flex items-center justify-center bg-white text-4xl font-bold">
        <span className="animate-bounce">Loading...</span>
      </div>
    )
  }

  return (
    <div className="flex flex-col items-center w-full">
      {user ? (
        <>
          <ProfileHeader user={user} />
          <ProfileContent user={user} posts={userPosts} />
        </>
      ) : (
        <p>Loading...</p>
      )}
    </div>
  )
}

export default ProfilePage



Nom du fichier: ./pages/profile/changePassword.jsx
Contenu:
import React, { useState, useEffect } from "react"
import { useRouter } from "next/router"
import useAppContext from "@/app/hooks/useContext.jsx"
import Toast from "@/app/components/common/Toast.jsx"
import PasswordChangeForm from "@/app/components/profile/PasswordChangeForm.jsx"
import PasswordChangeSuccessMessage from "@/app/components/profile/PasswordChangeSuccessMessage.jsx"

const ChangePassword = () => {
  const [passwords, setPasswords] = useState({
    oldPassword: "",
    newPassword: "",
    confirmPassword: ""
  })
  const [loading, setLoading] = useState(false)
  const [message, setMessage] = useState(null)
  const [success, setSuccess] = useState(false)
  const [countdown, setCountdown] = useState(5)
  const router = useRouter()
  const {
    state: { session },
    action: { changePassword }
  } = useAppContext()

  useEffect(() => {
    if (!session) {
      router.push("/login")
    }
  }, [session, router])

  const handleChange = e => {
    const { name, value } = e.target
    setPasswords(prev => ({
      ...prev,
      [name]: value
    }))
  }

  const handleSubmit = async e => {
    e.preventDefault()
    setLoading(true)

    if (passwords.newPassword !== passwords.confirmPassword) {
      setMessage({ text: "New passwords do not match!", type: "error" })
      setLoading(false)

      return
    }

    const passwordRegex = /^(?=.*[A-Z])(?=.*[!@#$%^&*])(?=.{8,})/

    if (!passwordRegex.test(passwords.newPassword)) {
      setMessage({
        text: "Password must be at least 8 characters long, contain 1 uppercase letter and 1 symbol.",
        type: "error"
      })
      setLoading(false)

      return
    }

    try {
      const [error, response] = await changePassword({
        idUser: session.id,
        oldPassword: passwords.oldPassword,
        newPassword: passwords.newPassword
      })

      if (error) {
        setMessage({ text: error, type: "error" })
        setLoading(false)

        return
      }

      setMessage({ text: response.message, type: "success" })
      setSuccess(true)

      const countdownInterval = setInterval(() => {
        setCountdown(prevCountdown => prevCountdown - 1)
      }, 1000)

      setTimeout(() => {
        clearInterval(countdownInterval)
        localStorage.removeItem("user")
        localStorage.removeItem("token")
        router.push("/login")
      }, 5000)
    } catch (error) {
      setMessage({ text: "Failed to update password. Please try again.", type: "error" })
      setLoading(false)
    }
  }

  const handleCancel = () => {
    const userId = session?.id
    router.push(`/profile/${userId}`)
  }

  return (
    <div className="flex items-center justify-center min-h-screen bg-gray-100">
      <div className="bg-white shadow-lg rounded-lg p-8 max-w-md w-full">
        <h1 className="text-2xl font-bold text-blue-600 mb-4">Change Password</h1>
        {!success ? (
          <>
            {message && (
              <div
                className={`mb-4 p-4 rounded ${message.type === "success" ? "bg-green-500 text-white" : "bg-red-500 text-white"}`}
              >
                {message.text}
              </div>
            )}
            <PasswordChangeForm
              passwords={passwords}
              handleChange={handleChange}
              handleSubmit={handleSubmit}
              handleCancel={handleCancel}
              loading={loading}
            />
          </>
        ) : (
          <PasswordChangeSuccessMessage countdown={countdown} />
        )}
      </div>
      {message && <Toast message={message.text} isSuccess={message.type === "success"} />}
    </div>
  )
}

export default ChangePassword



Nom du fichier: ./pages/profile/deleteProfile.jsx
Contenu:
import React, { useState } from "react"
import useAppContext from "@/app/hooks/useContext.jsx"
import { useRouter } from "next/router"
import DeleteProfileForm from "@/app/components/profile/delete/DeleteProfileForm"
import DeleteProfileMessage from "@/app/components/profile/delete/DeleteProfileMessage"
import DeleteProfileCountdown from "@/app/components/profile/delete/DeleteProfileCountdown"

const DeleteProfile = () => {
  const {
    state: { session },
    action: { deleteUserProfile }
  } = useAppContext()
  const [loading, setLoading] = useState(false)
  const [message, setMessage] = useState(null)
  const [success, setSuccess] = useState(false)
  const [countdown, setCountdown] = useState(5)
  const router = useRouter()

  const handleDelete = async password => {
    setLoading(true)

    try {
      // eslint-disable-next-line no-unused-vars
      const [error, data] = await deleteUserProfile({ userId: session.id, password })

      if (error) {
        throw new Error(error)
      }

      setSuccess(true)
      setMessage("Account deleted successfully!")
      setTimeout(() => {
        router.push("/login")
      }, 5000)
    } catch (error) {
      setMessage(error.message || "Error deleting account. Please try again.")
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="flex items-center justify-center min-h-screen bg-gray-100">
      <div className="bg-white shadow-lg rounded-lg p-8 max-w-md w-full">
        {!success ? (
          <DeleteProfileForm
            onDelete={handleDelete}
            loading={loading}
            message={message}
            success={success}
            router={router}
            session={session}
          />
        ) : (
          <>
            <DeleteProfileMessage countdown={countdown} />
            <DeleteProfileCountdown countdown={countdown} setCountdown={setCountdown} />
          </>
        )}
      </div>
    </div>
  )
}

export default DeleteProfile



Nom du fichier: ./pages/profile/editProfile.jsx
Contenu:
import React, { useState, useEffect } from "react"
import { useRouter } from "next/router"
import useAppContext from "@/app/hooks/useContext.jsx"
import EditProfileForm from "@/app/components/profile/edit/EditProfileForm"
import Countdown from "@/app/components/profile/edit/Countdown"

const EditProfile = () => {
  const [user, setUser] = useState({
    username: "",
    bio: "",
    profileImage: "",
    coverImage: ""
  })
  const [loading, setLoading] = useState(false)
  const [message, setMessage] = useState(null)
  const [success, setSuccess] = useState(false)
  const [countdown, setCountdown] = useState(5)
  const [profileImageOption, setProfileImageOption] = useState("current")
  const [coverImageOption, setCoverImageOption] = useState("current")
  const router = useRouter()
  const {
    state: { session },
    action: { updateUserProfile, getUserProfile }
  } = useAppContext()

  useEffect(() => {
    const fetchUserData = async () => {
      try {
        const userId = session.id

        if (!userId) {
          throw new Error("No user ID found")
        }

        const [error, data] = await getUserProfile({ userId })

        if (error) {
          throw new Error(error)
        }

        setUser({
          username: data.username,
          bio: data.bio,
          profileImage: data.profileImage || "",
          coverImage: data.coverImage || ""
        })
      } catch {
        router.push("/login")
      }
    }

    if (session) {
      fetchUserData()
    }
  }, [session, getUserProfile, router])

  useEffect(() => {
    if (profileImageOption === "random") {
      setUser(prev => ({
        ...prev,
        profileImage: `https://cloudflare-ipfs.com/ipfs/Qmd3W5DuhgHirLHGVixi6V76LhCkZUz6pnFt5AJBiyvHye/avatar/${Math.floor(Math.random() * 1000)}.jpg`
      }))
    } else if (profileImageOption === "default") {
      setUser(prev => ({
        ...prev,
        profileImage: "/images/default-profile-picture.jpg"
      }))
    } else {
      setUser(prev => ({
        ...prev,
        profileImage: JSON.parse(localStorage.getItem("user")).profileImage || ""
      }))
    }
  }, [profileImageOption])

  useEffect(() => {
    if (coverImageOption === "random") {
      setUser(prev => ({
        ...prev,
        coverImage: `https://cloudflare-ipfs.com/ipfs/Qmd3W5DuhgHirLHGVixi6V76LhCkZUz6pnFt5AJBiyvHye/avatar/${Math.floor(Math.random() * 1000)}.jpg`
      }))
    } else if (coverImageOption === "default") {
      setUser(prev => ({
        ...prev,
        coverImage: "/images/default-cover-picture.jpg"
      }))
    } else {
      setUser(prev => ({
        ...prev,
        coverImage: JSON.parse(localStorage.getItem("user")).coverImage || ""
      }))
    }
  }, [coverImageOption])

  const handleInputChange = e => {
    const { name, value } = e.target
    setUser(prev => ({
      ...prev,
      [name]: value
    }))
  }

  const handleSubmit = async e => {
    e.preventDefault()
    setLoading(true)

    try {
      const userId = session.id
      const [error, data] = await updateUserProfile({ userId, userData: user })

      if (error) {
        throw new Error(error)
      }

      setMessage({ text: "Profile updated successfully!", type: "success" })
      setSuccess(true)
      localStorage.setItem("user", JSON.stringify({ ...JSON.parse(localStorage.getItem("user")), ...data }))

      const countdownInterval = setInterval(() => {
        setCountdown(prevCountdown => prevCountdown - 1)
      }, 1000)

      setTimeout(() => {
        clearInterval(countdownInterval)
        router.push(`/profile/${userId}`)
      }, 5000)
    } catch (error) {
      setMessage({ text: error.message || "Failed to update profile. Please try again.", type: "error" })
      setLoading(false)
    }
  }

  const handleCancel = () => {
    const userId = session.id
    router.push(`/profile/${userId}`)
  }

  return (
    <div className="flex items-center justify-center min-h-screen bg-gray-100">
      <div className="bg-white shadow-lg rounded-lg p-8 max-w-md w-full">
        <h1 className="text-2xl font-bold text-blue-600 mb-4">Edit Profile</h1>
        {!success ? (
          <EditProfileForm
            user={user}
            handleInputChange={handleInputChange}
            handleSubmit={handleSubmit}
            loading={loading}
            message={message}
            profileImageOption={profileImageOption}
            setProfileImageOption={setProfileImageOption}
            coverImageOption={coverImageOption}
            setCoverImageOption={setCoverImageOption}
            handleCancel={handleCancel}
          />
        ) : (
          <Countdown countdown={countdown} setCountdown={setCountdown} userId={session.id} />
        )}
      </div>
    </div>
  )
}

export default EditProfile



Nom du fichier: ./pages/user/[id].jsx
Contenu:
import React, { useState, useEffect } from "react"
import { useRouter } from "next/router"
import ProfileHeader from "@/app/components/profile/ProfileHeader.jsx"
import ProfileContent from "@/app/components/profile/ProfileContent.jsx"
import useAppContext from "@/app/hooks/useContext.jsx"

const ProfilePage = () => {
  const [user, setUser] = useState(null)
  const [userPosts, setUserPosts] = useState([])
  const router = useRouter()
  const {
    state: { session },
    action: { getUserProfile, getUserPosts }
  } = useAppContext()

  useEffect(() => {
    const fetchUserData = async () => {
      try {
        const userId = router.query.id
        const [error, data] = await getUserProfile({ userId })

        if (error) {
          throw new Error(error)
        }

        setUser(data)

        const [postsError, postsData] = await getUserPosts({ userId })

        if (postsError) {
          throw new Error(postsError)
        }

        setUserPosts(postsData)
      } catch (err) {
        router.push("/login")
      }
    }

    fetchUserData()
  }, [router.query.id, getUserProfile, getUserPosts, router])

  if (!user) {
    return (
      <div className="fixed inset-0 flex items-center justify-center bg-white text-4xl font-bold">
        <span className="animate-bounce">Loading...</span>
      </div>
    )
  }

  const isOwnProfile = session && session.user && session.user.id === user.id

  return (
    <div className="flex flex-col items-center w-full">
      <ProfileHeader user={user} readOnly={!isOwnProfile} />
      <ProfileContent user={user} posts={userPosts} readOnly={!isOwnProfile} />
    </div>
  )
}

export default ProfilePage



